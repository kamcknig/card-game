import { isString } from '../predicate/isString.ts';
import { eq } from '../util/eq.ts';
import { toInteger } from '../util/toInteger.ts';
/**
 * Checks if a specified value exists within a given source, which can be an array, an object, or a string.
 *
 * The comparison uses SameValueZero to check for inclusion.
 *
 * @param {T[] | Record<string, any> | string} source - The source to search in. It can be an array, an object, or a string.
 * @param {T} [target] - The value to search for in the source.
 * @param {number} [fromIndex=0] - The index to start searching from. If negative, it is treated as an offset from the end of the source.
 * @returns {boolean} `true` if the value is found in the source, `false` otherwise.
 *
 * @example
 * includes([1, 2, 3], 2); // true
 * includes({ a: 1, b: 'a', c: NaN }, 'a'); // true
 * includes('hello world', 'world'); // true
 * includes('hello world', 'test'); // false
 */ export function includes(source, target, fromIndex, guard) {
  if (source == null) {
    return false;
  }
  if (guard || !fromIndex) {
    fromIndex = 0;
  } else {
    fromIndex = toInteger(fromIndex);
  }
  if (isString(source)) {
    if (fromIndex > source.length || target instanceof RegExp) {
      return false;
    }
    if (fromIndex < 0) {
      fromIndex = Math.max(0, source.length + fromIndex);
    }
    return source.includes(target, fromIndex);
  }
  if (Array.isArray(source)) {
    return source.includes(target, fromIndex);
  }
  const keys = Object.keys(source);
  if (fromIndex < 0) {
    fromIndex = Math.max(0, keys.length + fromIndex);
  }
  for(let i = fromIndex; i < keys.length; i++){
    const value = Reflect.get(source, keys[i]);
    if (eq(value, target)) {
      return true;
    }
  }
  return false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vanNyLmlvL0Blcy10b29sa2l0L2VzLXRvb2xraXQvMS4zMy4wL3NyYy9jb21wYXQvYXJyYXkvaW5jbHVkZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuLi9wcmVkaWNhdGUvaXNTdHJpbmcudHMnO1xuaW1wb3J0IHsgZXEgfSBmcm9tICcuLi91dGlsL2VxLnRzJztcbmltcG9ydCB7IHRvSW50ZWdlciB9IGZyb20gJy4uL3V0aWwvdG9JbnRlZ2VyLnRzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gaXRlbSBpcyBpbmNsdWRlZCBpbiBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge1RbXX0gYXJyIC0gVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAqIEBwYXJhbSB7VH0gaXRlbSAtIFRoZSBpdGVtIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSAtIFRoZSBpbmRleCB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS4gSWYgbmVnYXRpdmUsIGl0IGlzIHRyZWF0ZWQgYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBpdGVtIGlzIGZvdW5kIGluIHRoZSBhcnJheSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGluY2x1ZGVzKFsxLCAyLCAzXSwgMik7IC8vIHRydWVcbiAqIGluY2x1ZGVzKFsxLCAyLCAzXSwgNCk7IC8vIGZhbHNlXG4gKiBpbmNsdWRlcyhbMSwgMiwgM10sIDMsIC0xKTsgLy8gdHJ1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkZXM8VD4oYXJyOiByZWFkb25seSBUW10sIGl0ZW06IFQsIGZyb21JbmRleD86IG51bWJlcik6IGJvb2xlYW47XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgaW5jbHVkZWQgaW4gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VH0gb2JqIC0gVGhlIG9iamVjdCB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0ge1Rba2V5b2YgVF19IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSAtIFRoZSBpbmRleCB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS4gSWYgbmVnYXRpdmUsIGl0IGlzIHRyZWF0ZWQgYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCBpbiB0aGUgb2JqZWN0LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW5jbHVkZXMoeyBhOiAxLCBiOiAnYScsIGM6IE5hTiB9LCAxKTsgLy8gdHJ1ZVxuICogaW5jbHVkZXMoeyBhOiAxLCBiOiAnYScsIGM6IE5hTiB9LCAnYScpOyAvLyB0cnVlXG4gKiBpbmNsdWRlcyh7IGE6IDEsIGI6ICdhJywgYzogTmFOIH0sIE5hTik7IC8vIHRydWVcbiAqIGluY2x1ZGVzKHsgW1N5bWJvbCgnc3ltMScpXTogMSB9LCAxKTsgLy8gZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluY2x1ZGVzPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PihvYmo6IFQsIHZhbHVlOiBUW2tleW9mIFRdLCBmcm9tSW5kZXg/OiBudW1iZXIpOiBib29sZWFuO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN1YnN0cmluZyBpcyBpbmNsdWRlZCBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3Vic3RyIC0gVGhlIHN1YnN0cmluZyB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gLSBUaGUgaW5kZXggdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uIElmIG5lZ2F0aXZlLCBpdCBpcyB0cmVhdGVkIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN1YnN0cmluZyBpcyBmb3VuZCBpbiB0aGUgc3RyaW5nLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW5jbHVkZXMoJ2hlbGxvIHdvcmxkJywgJ3dvcmxkJyk7IC8vIHRydWVcbiAqIGluY2x1ZGVzKCdoZWxsbyB3b3JsZCcsICd0ZXN0Jyk7IC8vIGZhbHNlXG4gKiBpbmNsdWRlcygnaGVsbG8gd29ybGQnLCAnbycsIDUpOyAvLyB0cnVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRlcyhzdHI6IHN0cmluZywgc3Vic3RyOiBzdHJpbmcsIGZyb21JbmRleD86IG51bWJlcik6IGJvb2xlYW47XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3BlY2lmaWVkIHZhbHVlIGV4aXN0cyB3aXRoaW4gYSBnaXZlbiBzb3VyY2UsIHdoaWNoIGNhbiBiZSBhbiBhcnJheSwgYW4gb2JqZWN0LCBvciBhIHN0cmluZy5cbiAqXG4gKiBUaGUgY29tcGFyaXNvbiB1c2VzIFNhbWVWYWx1ZVplcm8gdG8gY2hlY2sgZm9yIGluY2x1c2lvbi5cbiAqXG4gKiBAcGFyYW0ge1RbXSB8IFJlY29yZDxzdHJpbmcsIGFueT4gfCBzdHJpbmd9IHNvdXJjZSAtIFRoZSBzb3VyY2UgdG8gc2VhcmNoIGluLiBJdCBjYW4gYmUgYW4gYXJyYXksIGFuIG9iamVjdCwgb3IgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge1R9IFt0YXJnZXRdIC0gVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IgaW4gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIC0gVGhlIGluZGV4IHRvIHN0YXJ0IHNlYXJjaGluZyBmcm9tLiBJZiBuZWdhdGl2ZSwgaXQgaXMgdHJlYXRlZCBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCBpbiB0aGUgc291cmNlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW5jbHVkZXMoWzEsIDIsIDNdLCAyKTsgLy8gdHJ1ZVxuICogaW5jbHVkZXMoeyBhOiAxLCBiOiAnYScsIGM6IE5hTiB9LCAnYScpOyAvLyB0cnVlXG4gKiBpbmNsdWRlcygnaGVsbG8gd29ybGQnLCAnd29ybGQnKTsgLy8gdHJ1ZVxuICogaW5jbHVkZXMoJ2hlbGxvIHdvcmxkJywgJ3Rlc3QnKTsgLy8gZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluY2x1ZGVzPFQ+KFxuICBzb3VyY2U6IHJlYWRvbmx5IFRbXSB8IFJlY29yZDxzdHJpbmcsIGFueT4gfCBzdHJpbmcsXG4gIHRhcmdldD86IFQsXG4gIGZyb21JbmRleD86IG51bWJlclxuKTogYm9vbGVhbjtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzcGVjaWZpZWQgdmFsdWUgZXhpc3RzIHdpdGhpbiBhIGdpdmVuIHNvdXJjZSwgd2hpY2ggY2FuIGJlIGFuIGFycmF5LCBhbiBvYmplY3QsIG9yIGEgc3RyaW5nLlxuICpcbiAqIFRoZSBjb21wYXJpc29uIHVzZXMgU2FtZVZhbHVlWmVybyB0byBjaGVjayBmb3IgaW5jbHVzaW9uLlxuICpcbiAqIEBwYXJhbSB7VFtdIHwgUmVjb3JkPHN0cmluZywgYW55PiB8IHN0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSB0byBzZWFyY2ggaW4uIEl0IGNhbiBiZSBhbiBhcnJheSwgYW4gb2JqZWN0LCBvciBhIHN0cmluZy5cbiAqIEBwYXJhbSB7VH0gW3RhcmdldF0gLSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvciBpbiB0aGUgc291cmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gLSBUaGUgaW5kZXggdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uIElmIG5lZ2F0aXZlLCBpdCBpcyB0cmVhdGVkIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGZvdW5kIGluIHRoZSBzb3VyY2UsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbmNsdWRlcyhbMSwgMiwgM10sIDIpOyAvLyB0cnVlXG4gKiBpbmNsdWRlcyh7IGE6IDEsIGI6ICdhJywgYzogTmFOIH0sICdhJyk7IC8vIHRydWVcbiAqIGluY2x1ZGVzKCdoZWxsbyB3b3JsZCcsICd3b3JsZCcpOyAvLyB0cnVlXG4gKiBpbmNsdWRlcygnaGVsbG8gd29ybGQnLCAndGVzdCcpOyAvLyBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkZXMoXG4gIHNvdXJjZTogcmVhZG9ubHkgdW5rbm93bltdIHwgUmVjb3JkPHN0cmluZywgYW55PiB8IHN0cmluZyxcbiAgdGFyZ2V0PzogdW5rbm93bixcbiAgZnJvbUluZGV4PzogbnVtYmVyLFxuICBndWFyZD86IHVua25vd25cbik6IGJvb2xlYW4ge1xuICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZ3VhcmQgfHwgIWZyb21JbmRleCkge1xuICAgIGZyb21JbmRleCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZnJvbUluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcoc291cmNlKSkge1xuICAgIGlmIChmcm9tSW5kZXggPiBzb3VyY2UubGVuZ3RoIHx8IHRhcmdldCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICBmcm9tSW5kZXggPSBNYXRoLm1heCgwLCBzb3VyY2UubGVuZ3RoICsgZnJvbUluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlLmluY2x1ZGVzKHRhcmdldCBhcyBhbnksIGZyb21JbmRleCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5pbmNsdWRlcyh0YXJnZXQsIGZyb21JbmRleCk7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgIGZyb21JbmRleCA9IE1hdGgubWF4KDAsIGtleXMubGVuZ3RoICsgZnJvbUluZGV4KTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSBmcm9tSW5kZXg7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSBSZWZsZWN0LmdldChzb3VyY2UsIGtleXNbaV0pO1xuXG4gICAgaWYgKGVxKHZhbHVlLCB0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxRQUFRLFFBQVEsMkJBQTJCO0FBQ3BELFNBQVMsRUFBRSxRQUFRLGdCQUFnQjtBQUNuQyxTQUFTLFNBQVMsUUFBUSx1QkFBdUI7QUFzRWpEOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE9BQU8sU0FBUyxTQUNkLE1BQXlELEVBQ3pELE1BQWdCLEVBQ2hCLFNBQWtCLEVBQ2xCLEtBQWU7RUFFZixJQUFJLFVBQVUsTUFBTTtJQUNsQixPQUFPO0VBQ1Q7RUFFQSxJQUFJLFNBQVMsQ0FBQyxXQUFXO0lBQ3ZCLFlBQVk7RUFDZCxPQUFPO0lBQ0wsWUFBWSxVQUFVO0VBQ3hCO0VBRUEsSUFBSSxTQUFTLFNBQVM7SUFDcEIsSUFBSSxZQUFZLE9BQU8sTUFBTSxJQUFJLGtCQUFrQixRQUFRO01BQ3pELE9BQU87SUFDVDtJQUVBLElBQUksWUFBWSxHQUFHO01BQ2pCLFlBQVksS0FBSyxHQUFHLENBQUMsR0FBRyxPQUFPLE1BQU0sR0FBRztJQUMxQztJQUVBLE9BQU8sT0FBTyxRQUFRLENBQUMsUUFBZTtFQUN4QztFQUVBLElBQUksTUFBTSxPQUFPLENBQUMsU0FBUztJQUN6QixPQUFPLE9BQU8sUUFBUSxDQUFDLFFBQVE7RUFDakM7RUFFQSxNQUFNLE9BQU8sT0FBTyxJQUFJLENBQUM7RUFFekIsSUFBSSxZQUFZLEdBQUc7SUFDakIsWUFBWSxLQUFLLEdBQUcsQ0FBQyxHQUFHLEtBQUssTUFBTSxHQUFHO0VBQ3hDO0VBRUEsSUFBSyxJQUFJLElBQUksV0FBVyxJQUFJLEtBQUssTUFBTSxFQUFFLElBQUs7SUFDNUMsTUFBTSxRQUFRLFFBQVEsR0FBRyxDQUFDLFFBQVEsSUFBSSxDQUFDLEVBQUU7SUFFekMsSUFBSSxHQUFHLE9BQU8sU0FBUztNQUNyQixPQUFPO0lBQ1Q7RUFDRjtFQUVBLE9BQU87QUFDVCJ9
// denoCacheMetadata=13826879545070307577,14746473319552547941