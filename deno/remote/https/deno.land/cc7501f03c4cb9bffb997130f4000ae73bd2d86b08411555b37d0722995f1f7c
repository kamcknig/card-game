import { decodeFromBase64, encodeToBase64 } from "./base64-arraybuffer.ts";

const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

export type PacketType =
  | "open"
  | "close"
  | "ping"
  | "pong"
  | "message"
  | "upgrade"
  | "noop"
  | "error";

export type RawData = string | ArrayBuffer | ArrayBufferView | Blob;

export interface Packet {
  type: PacketType;
  data?: RawData;
}

const PACKET_TYPES = new Map<PacketType, string>();
const PACKET_TYPES_REVERSE = new Map<string, PacketType>();

([
  "open",
  "close",
  "ping",
  "pong",
  "message",
  "upgrade",
  "noop",
] as PacketType[]).forEach((type, index) => {
  PACKET_TYPES.set(type, "" + index);
  PACKET_TYPES_REVERSE.set("" + index, type);
});

const ERROR_PACKET: Packet = { type: "error", data: "parser error" };

type BinaryType = "arraybuffer" | "blob";

export const Parser = {
  encodePacket(
    { type, data }: Packet,
    supportsBinary: boolean,
    callback: (encodedPacket: RawData) => void,
  ) {
    if (data instanceof Blob) {
      return supportsBinary
        ? callback(data)
        : encodeBlobAsBase64(data, callback);
    } else if (data instanceof ArrayBuffer) {
      return callback(supportsBinary ? data : "b" + encodeToBase64(data));
    } else if (ArrayBuffer.isView(data)) {
      if (supportsBinary) {
        return callback(data);
      } else {
        const array = new Uint8Array(
          data.buffer,
          data.byteOffset,
          data.byteLength,
        );
        return callback("b" + encodeToBase64(array));
      }
    }
    // plain string
    return callback(PACKET_TYPES.get(type) + (data || ""));
  },

  decodePacket(
    encodedPacket: RawData,
    binaryType?: BinaryType,
  ): Packet {
    if (typeof encodedPacket !== "string") {
      return {
        type: "message",
        data: mapBinary(encodedPacket, binaryType),
      };
    }
    const typeChar = encodedPacket.charAt(0);
    if (typeChar === "b") {
      const buffer = decodeFromBase64(encodedPacket.substring(1));
      return {
        type: "message",
        data: mapBinary(buffer, binaryType),
      };
    }
    if (!PACKET_TYPES_REVERSE.has(typeChar)) {
      return ERROR_PACKET;
    }
    const type = PACKET_TYPES_REVERSE.get(typeChar)!;
    return encodedPacket.length > 1
      ? {
        type,
        data: encodedPacket.substring(1),
      }
      : {
        type,
      };
  },

  encodePayload(
    packets: Packet[],
    callback: (encodedPayload: string) => void,
  ) {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;

    packets.forEach((packet, i) => {
      // force base64 encoding for binary packets
      this.encodePacket(packet, false, (encodedPacket) => {
        encodedPackets[i] = encodedPacket;
        if (++count === length) {
          callback(encodedPackets.join(SEPARATOR));
        }
      });
    });
  },

  decodePayload(
    encodedPayload: string,
    binaryType?: BinaryType,
  ): Packet[] {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
      const decodedPacket = this.decodePacket(encodedPackets[i], binaryType);
      packets.push(decodedPacket);
      if (decodedPacket.type === "error") {
        break;
      }
    }
    return packets;
  },
};

function encodeBlobAsBase64(
  data: Blob,
  callback: (encodedPacket: RawData) => void,
) {
  const fileReader = new FileReader();
  fileReader.onload = function () {
    const content = (fileReader.result as string).split(",")[1];
    callback("b" + content);
  };
  return fileReader.readAsDataURL(data);
}

function mapBinary(data: RawData, binaryType?: BinaryType) {
  switch (binaryType) {
    case "blob":
      return new Blob([data]);
    case "arraybuffer":
    default:
      return data; // assuming the data is already an ArrayBuffer
  }
}

// denoCacheMetadata={"headers":{"accept-ranges":"bytes","cross-origin-resource-policy":"same-origin","date":"Wed, 29 Jan 2025 15:36:35 GMT","server":"deno/gcp-us-east4","cross-origin-opener-policy":"same-origin","etag":"\"58a30dd8cd72c3033047abd94644213d\"","last-modified":"Thu, 09 Jan 2025 07:38:35 GMT","strict-transport-security":"max-age=63072000; includeSubDomains; preload","server-timing":"fetchSource;dur=20","x-amz-cf-id":"3nEECTAY4ic9tV0PnSl5bLo3gNd0KDmdAj0LClkO02MCuco5io11uw==","content-length":"4053","access-control-allow-origin":"*","referrer-policy":"strict-origin-when-cross-origin","vary":"Accept-Encoding, Origin","x-cache":"Hit from cloudfront","cache-control":"public, max-age=31536000, immutable","content-type":"application/typescript; charset=utf-8","x-frame-options":"DENY","cross-origin-embedder-policy":"same-origin","via":"http/2 edgeproxy-h","age":"12809340","x-amz-server-side-encryption":"AES256","x-amz-version-id":".UBKkZW84p9GQ2k7wlPmIVdQ_ta_EkEm","x-content-type-options":"nosniff","x-amz-replication-status":"COMPLETED","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox","x-amz-cf-pop":"IAD61-P1"},"url":"https://deno.land/x/socket_io@0.2.1/packages/engine.io-parser/mod.ts","time":1750974333}