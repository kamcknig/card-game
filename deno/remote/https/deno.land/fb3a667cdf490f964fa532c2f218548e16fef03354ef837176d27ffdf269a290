import {
  BufReader,
  BufWriter,
} from "../vendor/https/deno.land/std/io/buffer.ts";
import { readReply } from "./reply.ts";
import { ErrorReplyError } from "../errors.ts";
import { encoder } from "./_util.ts";
import type { RawOrError, RedisReply, RedisValue } from "./types.ts";

const CRLF = encoder.encode("\r\n");
const ArrayCode = encoder.encode("*");
const BulkCode = encoder.encode("$");

async function writeRequest(
  writer: BufWriter,
  command: string,
  args: RedisValue[],
) {
  const _args = args.filter((v) => v !== void 0 && v !== null);
  await writer.write(ArrayCode);
  await writer.write(encoder.encode(String(1 + _args.length)));
  await writer.write(CRLF);
  await writer.write(BulkCode);
  await writer.write(encoder.encode(String(command.length)));
  await writer.write(CRLF);
  await writer.write(encoder.encode(command));
  await writer.write(CRLF);
  for (const arg of _args) {
    const bytes = arg instanceof Uint8Array ? arg : encoder.encode(String(arg));
    const bytesLen = bytes.byteLength;
    await writer.write(BulkCode);
    await writer.write(encoder.encode(String(bytesLen)));
    await writer.write(CRLF);
    await writer.write(bytes);
    await writer.write(CRLF);
  }
}

export async function sendCommand(
  writer: BufWriter,
  reader: BufReader,
  command: string,
  ...args: RedisValue[]
): Promise<RedisReply> {
  await writeRequest(writer, command, args);
  await writer.flush();
  return readReply(reader);
}

export async function sendCommands(
  writer: BufWriter,
  reader: BufReader,
  commands: {
    command: string;
    args: RedisValue[];
  }[],
): Promise<RawOrError[]> {
  for (const { command, args } of commands) {
    await writeRequest(writer, command, args);
  }
  await writer.flush();
  const ret: RawOrError[] = [];
  for (let i = 0; i < commands.length; i++) {
    try {
      const rep = await readReply(reader);
      ret.push(rep.value());
    } catch (e) {
      if (e instanceof ErrorReplyError) {
        ret.push(e);
      } else {
        throw e;
      }
    }
  }
  return ret;
}

// denoCacheMetadata={"headers":{"etag":"\"d1d8f020493ef7b021a5df96193c16d0\"","last-modified":"Thu, 09 Jan 2025 07:38:36 GMT","cross-origin-embedder-policy":"same-origin","accept-ranges":"bytes","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox","referrer-policy":"strict-origin-when-cross-origin","x-amz-cf-pop":"IAD61-P1","cross-origin-resource-policy":"same-origin","x-amz-cf-id":"WH6j3BH_KnsRKk6m_WC-BLRbSkpuNbCrwwaxEGPowPmvI8LAdw7QbA==","x-frame-options":"DENY","server":"deno/gcp-us-east4","server-timing":"fetchSource;dur=16","x-amz-replication-status":"COMPLETED","x-amz-version-id":"pf4YO48lwGY0RVWaGqDFuGX1dUJ.jcXs","cache-control":"public, max-age=31536000, immutable","content-length":"2064","x-content-type-options":"nosniff","content-type":"application/typescript; charset=utf-8","cross-origin-opener-policy":"same-origin","vary":"Accept-Encoding, Origin","x-amz-server-side-encryption":"AES256","date":"Wed, 29 Jan 2025 15:36:35 GMT","age":"12809340","via":"http/2 edgeproxy-h","strict-transport-security":"max-age=63072000; includeSubDomains; preload","x-cache":"Hit from cloudfront","access-control-allow-origin":"*"},"url":"https://deno.land/x/socket_io@0.2.1/vendor/deno.land/x/redis@v0.27.1/protocol/command.ts","time":1750974333}