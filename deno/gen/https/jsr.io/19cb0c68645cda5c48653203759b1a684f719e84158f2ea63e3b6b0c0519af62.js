/**
 * Clamps a number within the inclusive upper bound.
 *
 * This function takes a number and a maximum bound, and returns the number clamped within the specified upper bound.
 * If only one bound is provided, it returns the minimum of the value and the bound.
 *
 * @param {number} value - The number to clamp.
 * @param {number} maximum - The maximum bound to clamp the number.
 * @returns {number} The clamped number within the specified upper bound.
 *
 * @example
 * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5
 */ /**
 * Clamps a number within the specified bounds.
 *
 * This function takes a number and one or two bounds, and returns the number clamped within the specified bounds.
 * If only one bound is provided, it returns the minimum of the value and the bound.
 *
 * @param {number} value - The number to clamp.
 * @param {number} bound1 - The minimum bound to clamp the number, or the maximum bound if bound2 is not provided.
 * @param {number} [bound2] - The maximum bound to clamp the number. If not provided, the function will only consider bound1 as the upper limit.
 * @returns {number} The clamped number within the specified bounds.
 *
 * @example
 * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5
 * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15
 * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5
 * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15
 */ export function clamp(value, bound1, bound2) {
  if (bound2 == null) {
    return Math.min(value, bound1);
  }
  return Math.min(Math.max(value, bound1), bound2);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vanNyLmlvL0Blcy10b29sa2l0L2VzLXRvb2xraXQvMS4zMy4wL3NyYy9tYXRoL2NsYW1wLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2xhbXBzIGEgbnVtYmVyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHVwcGVyIGJvdW5kLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBudW1iZXIgYW5kIGEgbWF4aW11bSBib3VuZCwgYW5kIHJldHVybnMgdGhlIG51bWJlciBjbGFtcGVkIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHVwcGVyIGJvdW5kLlxuICogSWYgb25seSBvbmUgYm91bmQgaXMgcHJvdmlkZWQsIGl0IHJldHVybnMgdGhlIG1pbmltdW0gb2YgdGhlIHZhbHVlIGFuZCB0aGUgYm91bmQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIG51bWJlciB0byBjbGFtcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhpbXVtIC0gVGhlIG1heGltdW0gYm91bmQgdG8gY2xhbXAgdGhlIG51bWJlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjbGFtcGVkIG51bWJlciB3aXRoaW4gdGhlIHNwZWNpZmllZCB1cHBlciBib3VuZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcmVzdWx0MSA9IGNsYW1wKDEwLCA1KTsgLy8gcmVzdWx0MSB3aWxsIGJlIDUsIGFzIDEwIGlzIGNsYW1wZWQgdG8gdGhlIGJvdW5kIDVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlOiBudW1iZXIsIG1heGltdW06IG51bWJlcik6IG51bWJlcjtcblxuLyoqXG4gKiBDbGFtcHMgYSBudW1iZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgbnVtYmVyIGFuZCB0d28gYm91bmRzLCBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIGNsYW1wZWQgd2l0aGluIHRoZSBzcGVjaWZpZWQgYm91bmRzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluaW11bSAtIFRoZSBtaW5pbXVtIGJvdW5kIHRvIGNsYW1wIHRoZSBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4aW11bSAtIFRoZSBtYXhpbXVtIGJvdW5kIHRvIGNsYW1wIHRoZSBudW1iZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY2xhbXBlZCBudW1iZXIgd2l0aGluIHRoZSBzcGVjaWZpZWQgYm91bmRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByZXN1bHQyID0gY2xhbXAoMTAsIDUsIDE1KTsgLy8gcmVzdWx0MiB3aWxsIGJlIDEwLCBhcyBpdCBpcyB3aXRoaW4gdGhlIGJvdW5kcyA1IGFuZCAxNVxuICogY29uc3QgcmVzdWx0MyA9IGNsYW1wKDIsIDUsIDE1KTsgLy8gcmVzdWx0MyB3aWxsIGJlIDUsIGFzIDIgaXMgY2xhbXBlZCB0byB0aGUgbG93ZXIgYm91bmQgNVxuICogY29uc3QgcmVzdWx0NCA9IGNsYW1wKDIwLCA1LCAxNSk7IC8vIHJlc3VsdDQgd2lsbCBiZSAxNSwgYXMgMjAgaXMgY2xhbXBlZCB0byB0aGUgdXBwZXIgYm91bmQgMTVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlOiBudW1iZXIsIG1pbmltdW06IG51bWJlciwgbWF4aW11bTogbnVtYmVyKTogbnVtYmVyO1xuXG4vKipcbiAqIENsYW1wcyBhIG51bWJlciB3aXRoaW4gdGhlIHNwZWNpZmllZCBib3VuZHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG51bWJlciBhbmQgb25lIG9yIHR3byBib3VuZHMsIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgY2xhbXBlZCB3aXRoaW4gdGhlIHNwZWNpZmllZCBib3VuZHMuXG4gKiBJZiBvbmx5IG9uZSBib3VuZCBpcyBwcm92aWRlZCwgaXQgcmV0dXJucyB0aGUgbWluaW11bSBvZiB0aGUgdmFsdWUgYW5kIHRoZSBib3VuZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kMSAtIFRoZSBtaW5pbXVtIGJvdW5kIHRvIGNsYW1wIHRoZSBudW1iZXIsIG9yIHRoZSBtYXhpbXVtIGJvdW5kIGlmIGJvdW5kMiBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2JvdW5kMl0gLSBUaGUgbWF4aW11bSBib3VuZCB0byBjbGFtcCB0aGUgbnVtYmVyLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBmdW5jdGlvbiB3aWxsIG9ubHkgY29uc2lkZXIgYm91bmQxIGFzIHRoZSB1cHBlciBsaW1pdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjbGFtcGVkIG51bWJlciB3aXRoaW4gdGhlIHNwZWNpZmllZCBib3VuZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJlc3VsdDEgPSBjbGFtcCgxMCwgNSk7IC8vIHJlc3VsdDEgd2lsbCBiZSA1LCBhcyAxMCBpcyBjbGFtcGVkIHRvIHRoZSBib3VuZCA1XG4gKiBjb25zdCByZXN1bHQyID0gY2xhbXAoMTAsIDUsIDE1KTsgLy8gcmVzdWx0MiB3aWxsIGJlIDEwLCBhcyBpdCBpcyB3aXRoaW4gdGhlIGJvdW5kcyA1IGFuZCAxNVxuICogY29uc3QgcmVzdWx0MyA9IGNsYW1wKDIsIDUsIDE1KTsgLy8gcmVzdWx0MyB3aWxsIGJlIDUsIGFzIDIgaXMgY2xhbXBlZCB0byB0aGUgbG93ZXIgYm91bmQgNVxuICogY29uc3QgcmVzdWx0NCA9IGNsYW1wKDIwLCA1LCAxNSk7IC8vIHJlc3VsdDQgd2lsbCBiZSAxNSwgYXMgMjAgaXMgY2xhbXBlZCB0byB0aGUgdXBwZXIgYm91bmQgMTVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlOiBudW1iZXIsIGJvdW5kMTogbnVtYmVyLCBib3VuZDI/OiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoYm91bmQyID09IG51bGwpIHtcbiAgICByZXR1cm4gTWF0aC5taW4odmFsdWUsIGJvdW5kMSk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIGJvdW5kMSksIGJvdW5kMik7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztDQVlDLEdBb0JEOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0QsT0FBTyxTQUFTLE1BQU0sS0FBYSxFQUFFLE1BQWMsRUFBRSxNQUFlO0VBQ2xFLElBQUksVUFBVSxNQUFNO0lBQ2xCLE9BQU8sS0FBSyxHQUFHLENBQUMsT0FBTztFQUN6QjtFQUVBLE9BQU8sS0FBSyxHQUFHLENBQUMsS0FBSyxHQUFHLENBQUMsT0FBTyxTQUFTO0FBQzNDIn0=
// denoCacheMetadata=2909485303882095641,9071230459681589053