// deno-lint-ignore-file
/**
 * An events map is an interface that maps event names to their value, which represents the type of the `on` listener.
 */ /**
 * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type parameters for mappings of event names
 * to event data types, and strictly types method calls to the `EventEmitter` according to these event maps.
 *
 * @typeParam ListenEvents - `EventsMap` of user-defined events that can be listened to with `on` or `once`
 * @typeParam EmitEvents - `EventsMap` of user-defined events that can be emitted with `emit`
 * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be emitted with `emitReserved`, and can be
 * listened to with `listen`.
 */ class BaseEventEmitter {
  _listeners = new Map();
  /**
   * Adds the `listener` function as an event listener for `ev`.
   *
   * @param event - Name of the event
   * @param listener - Callback function
   */ on(event, listener) {
    const listeners = this._listeners.get(event);
    if (listeners) {
      listeners.push(listener);
    } else {
      this._listeners.set(event, [
        listener
      ]);
    }
    return this;
  }
  /**
   * Adds a one-time `listener` function as an event listener for `ev`.
   *
   * @param event - Name of the event
   * @param listener - Callback function
   */ once(event, listener) {
    // @ts-ignore force listener type
    const onceListener = (...args)=>{
      this.off(event, onceListener);
      listener.apply(this, args);
    };
    // to work with .off(event, listener)
    onceListener.fn = listener;
    return this.on(event, onceListener);
  }
  /**
   * Removes the `listener` function as an event listener for `ev`.
   *
   * @param event - Name of the event
   * @param listener - Callback function
   */ off(event, listener) {
    if (!event) {
      this._listeners.clear();
      return this;
    }
    if (!listener) {
      this._listeners.delete(event);
      return this;
    }
    const listeners = this._listeners.get(event);
    if (!listeners) {
      return this;
    }
    for(let i = 0; i < listeners.length; i++){
      if (listeners[i] === listener || listeners[i].fn === listener) {
        listeners.splice(i, 1);
        break;
      }
    }
    if (listeners.length === 0) {
      this._listeners.delete(event);
    }
    return this;
  }
  /**
   * Emits an event.
   *
   * @param event - Name of the event
   * @param args - Values to send to listeners of this event
   */ emit(event, ...args) {
    const listeners = this._listeners.get(event);
    if (!listeners) {
      return false;
    }
    if (listeners.length === 1) {
      listeners[0].apply(this, args);
    } else {
      for (const listener of listeners.slice()){
        listener.apply(this, args);
      }
    }
    return true;
  }
  /**
   * Returns the listeners listening to an event.
   *
   * @param event - Event name
   * @returns Array of listeners subscribed to `event`
   */ listeners(event) {
    return this._listeners.get(event) || [];
  }
}
/**
 * This class extends the BaseEventEmitter abstract class, so a class extending `EventEmitter` can override the `emit`
 * method and still call `emitReserved()` (since it uses `super.emit()`)
 */ export class EventEmitter extends BaseEventEmitter {
  /**
   * Emits a reserved event.
   *
   * This method is `protected`, so that only a class extending `EventEmitter` can emit its own reserved events.
   *
   * @param event - Reserved event name
   * @param args - Arguments to emit along with the event
   * @protected
   */ emitReserved(event, ...args) {
    return super.emit(event, ...args);
  }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvc29ja2V0X2lvQDAuMi4xL3BhY2thZ2VzL2V2ZW50LWVtaXR0ZXIvbW9kLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGRlbm8tbGludC1pZ25vcmUtZmlsZVxuXG4vKipcbiAqIEFuIGV2ZW50cyBtYXAgaXMgYW4gaW50ZXJmYWNlIHRoYXQgbWFwcyBldmVudCBuYW1lcyB0byB0aGVpciB2YWx1ZSwgd2hpY2ggcmVwcmVzZW50cyB0aGUgdHlwZSBvZiB0aGUgYG9uYCBsaXN0ZW5lci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFdmVudHNNYXAge1xuICBbZXZlbnQ6IHN0cmluZ106IGFueTtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBldmVudHMgbWFwLCB1c2VkIGlmIG5vIEV2ZW50c01hcCBpcyBnaXZlbi4gVXNpbmcgdGhpcyBFdmVudHNNYXAgaXMgZXF1aXZhbGVudCB0byBhY2NlcHRpbmcgYWxsIGV2ZW50XG4gKiBuYW1lcywgYW5kIGFueSBkYXRhLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRFdmVudHNNYXAge1xuICBbZXZlbnQ6IHN0cmluZ106ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdW5pb24gdHlwZSBjb250YWluaW5nIGFsbCB0aGUga2V5cyBvZiBhbiBldmVudCBtYXAuXG4gKi9cbmV4cG9ydCB0eXBlIEV2ZW50TmFtZXM8TWFwIGV4dGVuZHMgRXZlbnRzTWFwPiA9IGtleW9mIE1hcCAmIChzdHJpbmcgfCBzeW1ib2wpO1xuXG4vKiogVGhlIHR1cGxlIHR5cGUgcmVwcmVzZW50aW5nIHRoZSBwYXJhbWV0ZXJzIG9mIGFuIGV2ZW50IGxpc3RlbmVyICovXG5leHBvcnQgdHlwZSBFdmVudFBhcmFtczxcbiAgTWFwIGV4dGVuZHMgRXZlbnRzTWFwLFxuICBFdiBleHRlbmRzIEV2ZW50TmFtZXM8TWFwPixcbj4gPSBQYXJhbWV0ZXJzPE1hcFtFdl0+O1xuXG4vKipcbiAqIFRoZSBldmVudCBuYW1lcyB0aGF0IGFyZSBlaXRoZXIgaW4gUmVzZXJ2ZWRFdmVudHMgb3IgaW4gVXNlckV2ZW50c1xuICovXG5leHBvcnQgdHlwZSBSZXNlcnZlZE9yVXNlckV2ZW50TmFtZXM8XG4gIFJlc2VydmVkRXZlbnRzTWFwIGV4dGVuZHMgRXZlbnRzTWFwLFxuICBVc2VyRXZlbnRzIGV4dGVuZHMgRXZlbnRzTWFwLFxuPiA9IEV2ZW50TmFtZXM8UmVzZXJ2ZWRFdmVudHNNYXA+IHwgRXZlbnROYW1lczxVc2VyRXZlbnRzPjtcblxuLyoqXG4gKiBUeXBlIG9mIGEgbGlzdGVuZXIgb2YgYSB1c2VyIGV2ZW50IG9yIGEgcmVzZXJ2ZWQgZXZlbnQuIElmIGBFdmAgaXMgaW4gYFJlc2VydmVkRXZlbnRzYCwgdGhlIHJlc2VydmVkIGV2ZW50IGxpc3RlbmVyXG4gKiBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IHR5cGUgUmVzZXJ2ZWRPclVzZXJMaXN0ZW5lcjxcbiAgUmVzZXJ2ZWRFdmVudHMgZXh0ZW5kcyBFdmVudHNNYXAsXG4gIFVzZXJFdmVudHMgZXh0ZW5kcyBFdmVudHNNYXAsXG4gIEV2IGV4dGVuZHMgUmVzZXJ2ZWRPclVzZXJFdmVudE5hbWVzPFJlc2VydmVkRXZlbnRzLCBVc2VyRXZlbnRzPixcbj4gPSBGYWxsYmFja1RvVW50eXBlZExpc3RlbmVyPFxuICBFdiBleHRlbmRzIEV2ZW50TmFtZXM8UmVzZXJ2ZWRFdmVudHM+ID8gUmVzZXJ2ZWRFdmVudHNbRXZdXG4gICAgOiBFdiBleHRlbmRzIEV2ZW50TmFtZXM8VXNlckV2ZW50cz4gPyBVc2VyRXZlbnRzW0V2XVxuICAgIDogbmV2ZXJcbj47XG5cbi8qKlxuICogUmV0dXJucyBhbiB1bnR5cGVkIGxpc3RlbmVyIHR5cGUgaWYgYFRgIGlzIGBuZXZlcmA7IG90aGVyd2lzZSwgcmV0dXJucyBgVGAuXG4gKlxuICogTmVlZGVkIGJlY2F1c2Ugb2YgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80MTc3OFxuICovXG50eXBlIEZhbGxiYWNrVG9VbnR5cGVkTGlzdGVuZXI8VD4gPSBbVF0gZXh0ZW5kcyBbbmV2ZXJdXG4gID8gKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPlxuICA6IFQ7XG5cbi8qKlxuICogU3RyaWN0bHkgdHlwZWQgdmVyc2lvbiBvZiBhbiBgRXZlbnRFbWl0dGVyYC4gQSBgVHlwZWRFdmVudEVtaXR0ZXJgIHRha2VzIHR5cGUgcGFyYW1ldGVycyBmb3IgbWFwcGluZ3Mgb2YgZXZlbnQgbmFtZXNcbiAqIHRvIGV2ZW50IGRhdGEgdHlwZXMsIGFuZCBzdHJpY3RseSB0eXBlcyBtZXRob2QgY2FsbHMgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGFjY29yZGluZyB0byB0aGVzZSBldmVudCBtYXBzLlxuICpcbiAqIEB0eXBlUGFyYW0gTGlzdGVuRXZlbnRzIC0gYEV2ZW50c01hcGAgb2YgdXNlci1kZWZpbmVkIGV2ZW50cyB0aGF0IGNhbiBiZSBsaXN0ZW5lZCB0byB3aXRoIGBvbmAgb3IgYG9uY2VgXG4gKiBAdHlwZVBhcmFtIEVtaXRFdmVudHMgLSBgRXZlbnRzTWFwYCBvZiB1c2VyLWRlZmluZWQgZXZlbnRzIHRoYXQgY2FuIGJlIGVtaXR0ZWQgd2l0aCBgZW1pdGBcbiAqIEB0eXBlUGFyYW0gUmVzZXJ2ZWRFdmVudHMgLSBgRXZlbnRzTWFwYCBvZiByZXNlcnZlZCBldmVudHMsIHRoYXQgY2FuIGJlIGVtaXR0ZWQgd2l0aCBgZW1pdFJlc2VydmVkYCwgYW5kIGNhbiBiZVxuICogbGlzdGVuZWQgdG8gd2l0aCBgbGlzdGVuYC5cbiAqL1xuYWJzdHJhY3QgY2xhc3MgQmFzZUV2ZW50RW1pdHRlcjxcbiAgTGlzdGVuRXZlbnRzIGV4dGVuZHMgRXZlbnRzTWFwLFxuICBFbWl0RXZlbnRzIGV4dGVuZHMgRXZlbnRzTWFwLFxuICBSZXNlcnZlZEV2ZW50cyBleHRlbmRzIEV2ZW50c01hcCA9IG5ldmVyLFxuPiB7XG4gIHByaXZhdGUgX2xpc3RlbmVyczogTWFwPFxuICAgIFJlc2VydmVkT3JVc2VyRXZlbnROYW1lczxSZXNlcnZlZEV2ZW50cywgTGlzdGVuRXZlbnRzPixcbiAgICBBcnJheTxSZXNlcnZlZE9yVXNlckxpc3RlbmVyPFJlc2VydmVkRXZlbnRzLCBMaXN0ZW5FdmVudHMsIGFueT4+XG4gID4gPSBuZXcgTWFwKCk7XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGBsaXN0ZW5lcmAgZnVuY3Rpb24gYXMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBldmAuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIE5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBwdWJsaWMgb248RXYgZXh0ZW5kcyBSZXNlcnZlZE9yVXNlckV2ZW50TmFtZXM8UmVzZXJ2ZWRFdmVudHMsIExpc3RlbkV2ZW50cz4+KFxuICAgIGV2ZW50OiBFdixcbiAgICBsaXN0ZW5lcjogUmVzZXJ2ZWRPclVzZXJMaXN0ZW5lcjxSZXNlcnZlZEV2ZW50cywgTGlzdGVuRXZlbnRzLCBFdj4sXG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycy5nZXQoZXZlbnQpO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnNldChldmVudCwgW2xpc3RlbmVyXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBvbmUtdGltZSBgbGlzdGVuZXJgIGZ1bmN0aW9uIGFzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBgZXZgLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBOYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBDYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgcHVibGljIG9uY2U8XG4gICAgRXYgZXh0ZW5kcyBSZXNlcnZlZE9yVXNlckV2ZW50TmFtZXM8UmVzZXJ2ZWRFdmVudHMsIExpc3RlbkV2ZW50cz4sXG4gID4oXG4gICAgZXZlbnQ6IEV2LFxuICAgIGxpc3RlbmVyOiBSZXNlcnZlZE9yVXNlckxpc3RlbmVyPFJlc2VydmVkRXZlbnRzLCBMaXN0ZW5FdmVudHMsIEV2PixcbiAgKTogdGhpcyB7XG4gICAgLy8gQHRzLWlnbm9yZSBmb3JjZSBsaXN0ZW5lciB0eXBlXG4gICAgY29uc3Qgb25jZUxpc3RlbmVyOiBSZXNlcnZlZE9yVXNlckxpc3RlbmVyPFxuICAgICAgUmVzZXJ2ZWRFdmVudHMsXG4gICAgICBMaXN0ZW5FdmVudHMsXG4gICAgICBFdlxuICAgID4gPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgIHRoaXMub2ZmKGV2ZW50LCBvbmNlTGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIC8vIHRvIHdvcmsgd2l0aCAub2ZmKGV2ZW50LCBsaXN0ZW5lcilcbiAgICBvbmNlTGlzdGVuZXIuZm4gPSBsaXN0ZW5lcjtcblxuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBvbmNlTGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGBsaXN0ZW5lcmAgZnVuY3Rpb24gYXMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBldmAuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIE5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBwdWJsaWMgb2ZmPEV2IGV4dGVuZHMgUmVzZXJ2ZWRPclVzZXJFdmVudE5hbWVzPFJlc2VydmVkRXZlbnRzLCBMaXN0ZW5FdmVudHM+PihcbiAgICBldmVudD86IEV2LFxuICAgIGxpc3RlbmVyPzogUmVzZXJ2ZWRPclVzZXJMaXN0ZW5lcjxSZXNlcnZlZEV2ZW50cywgTGlzdGVuRXZlbnRzLCBFdj4sXG4gICk6IHRoaXMge1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5jbGVhcigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLmRlbGV0ZShldmVudCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZ2V0KGV2ZW50KTtcblxuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdGVuZXJzW2ldLmZuID09PSBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLmRlbGV0ZShldmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIE5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBhcmdzIC0gVmFsdWVzIHRvIHNlbmQgdG8gbGlzdGVuZXJzIG9mIHRoaXMgZXZlbnRcbiAgICovXG4gIHB1YmxpYyBlbWl0PEV2IGV4dGVuZHMgRXZlbnROYW1lczxFbWl0RXZlbnRzPj4oXG4gICAgZXZlbnQ6IEV2LFxuICAgIC4uLmFyZ3M6IEV2ZW50UGFyYW1zPEVtaXRFdmVudHMsIEV2PlxuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZ2V0KGV2ZW50IGFzIEV2ZW50TmFtZXM8TGlzdGVuRXZlbnRzPik7XG5cbiAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0ZW5lcnNbMF0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzLnNsaWNlKCkpIHtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhbiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnQgbmFtZVxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBsaXN0ZW5lcnMgc3Vic2NyaWJlZCB0byBgZXZlbnRgXG4gICAqL1xuICBwdWJsaWMgbGlzdGVuZXJzPFxuICAgIEV2IGV4dGVuZHMgUmVzZXJ2ZWRPclVzZXJFdmVudE5hbWVzPFJlc2VydmVkRXZlbnRzLCBMaXN0ZW5FdmVudHM+LFxuICA+KFxuICAgIGV2ZW50OiBFdixcbiAgKTogUmVzZXJ2ZWRPclVzZXJMaXN0ZW5lcjxSZXNlcnZlZEV2ZW50cywgTGlzdGVuRXZlbnRzLCBFdj5bXSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycy5nZXQoZXZlbnQpIHx8IFtdO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBjbGFzcyBleHRlbmRzIHRoZSBCYXNlRXZlbnRFbWl0dGVyIGFic3RyYWN0IGNsYXNzLCBzbyBhIGNsYXNzIGV4dGVuZGluZyBgRXZlbnRFbWl0dGVyYCBjYW4gb3ZlcnJpZGUgdGhlIGBlbWl0YFxuICogbWV0aG9kIGFuZCBzdGlsbCBjYWxsIGBlbWl0UmVzZXJ2ZWQoKWAgKHNpbmNlIGl0IHVzZXMgYHN1cGVyLmVtaXQoKWApXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEVtaXR0ZXI8XG4gIExpc3RlbkV2ZW50cyBleHRlbmRzIEV2ZW50c01hcCxcbiAgRW1pdEV2ZW50cyBleHRlbmRzIEV2ZW50c01hcCxcbiAgUmVzZXJ2ZWRFdmVudHMgZXh0ZW5kcyBFdmVudHNNYXAgPSBuZXZlcixcbj4gZXh0ZW5kcyBCYXNlRXZlbnRFbWl0dGVyPExpc3RlbkV2ZW50cywgRW1pdEV2ZW50cywgUmVzZXJ2ZWRFdmVudHM+IHtcbiAgLyoqXG4gICAqIEVtaXRzIGEgcmVzZXJ2ZWQgZXZlbnQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGBwcm90ZWN0ZWRgLCBzbyB0aGF0IG9ubHkgYSBjbGFzcyBleHRlbmRpbmcgYEV2ZW50RW1pdHRlcmAgY2FuIGVtaXQgaXRzIG93biByZXNlcnZlZCBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFJlc2VydmVkIGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIGFyZ3MgLSBBcmd1bWVudHMgdG8gZW1pdCBhbG9uZyB3aXRoIHRoZSBldmVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgZW1pdFJlc2VydmVkPEV2IGV4dGVuZHMgRXZlbnROYW1lczxSZXNlcnZlZEV2ZW50cz4+KFxuICAgIGV2ZW50OiBFdixcbiAgICAuLi5hcmdzOiBFdmVudFBhcmFtczxSZXNlcnZlZEV2ZW50cywgRXY+XG4gICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50IGFzIEV2ZW50TmFtZXM8RW1pdEV2ZW50cz4sIC4uLmFyZ3MpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsd0JBQXdCO0FBRXhCOztDQUVDLEdBdUREOzs7Ozs7OztDQVFDLEdBQ0QsTUFBZTtFQUtMLGFBR0osSUFBSSxNQUFNO0VBRWQ7Ozs7O0dBS0MsR0FDRCxBQUFPLEdBQ0wsS0FBUyxFQUNULFFBQWtFLEVBQzVEO0lBQ04sTUFBTSxZQUFZLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDO0lBQ3RDLElBQUksV0FBVztNQUNiLFVBQVUsSUFBSSxDQUFDO0lBQ2pCLE9BQU87TUFDTCxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxPQUFPO1FBQUM7T0FBUztJQUN2QztJQUNBLE9BQU8sSUFBSTtFQUNiO0VBRUE7Ozs7O0dBS0MsR0FDRCxBQUFPLEtBR0wsS0FBUyxFQUNULFFBQWtFLEVBQzVEO0lBQ04saUNBQWlDO0lBQ2pDLE1BQU0sZUFJRixDQUFDLEdBQUc7TUFDTixJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU87TUFDaEIsU0FBUyxLQUFLLENBQUMsSUFBSSxFQUFFO0lBQ3ZCO0lBRUEscUNBQXFDO0lBQ3JDLGFBQWEsRUFBRSxHQUFHO0lBRWxCLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPO0VBQ3hCO0VBRUE7Ozs7O0dBS0MsR0FDRCxBQUFPLElBQ0wsS0FBVSxFQUNWLFFBQW1FLEVBQzdEO0lBQ04sSUFBSSxDQUFDLE9BQU87TUFDVixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUs7TUFDckIsT0FBTyxJQUFJO0lBQ2I7SUFFQSxJQUFJLENBQUMsVUFBVTtNQUNiLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDO01BQ3ZCLE9BQU8sSUFBSTtJQUNiO0lBRUEsTUFBTSxZQUFZLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDO0lBRXRDLElBQUksQ0FBQyxXQUFXO01BQ2QsT0FBTyxJQUFJO0lBQ2I7SUFFQSxJQUFLLElBQUksSUFBSSxHQUFHLElBQUksVUFBVSxNQUFNLEVBQUUsSUFBSztNQUN6QyxJQUFJLFNBQVMsQ0FBQyxFQUFFLEtBQUssWUFBWSxTQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxVQUFVO1FBQzdELFVBQVUsTUFBTSxDQUFDLEdBQUc7UUFDcEI7TUFDRjtJQUNGO0lBRUEsSUFBSSxVQUFVLE1BQU0sS0FBSyxHQUFHO01BQzFCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDO0lBQ3pCO0lBRUEsT0FBTyxJQUFJO0VBQ2I7RUFFQTs7Ozs7R0FLQyxHQUNELEFBQU8sS0FDTCxLQUFTLEVBQ1QsR0FBRyxJQUFpQyxFQUMzQjtJQUNULE1BQU0sWUFBWSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUV0QyxJQUFJLENBQUMsV0FBVztNQUNkLE9BQU87SUFDVDtJQUVBLElBQUksVUFBVSxNQUFNLEtBQUssR0FBRztNQUMxQixTQUFTLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUU7SUFDM0IsT0FBTztNQUNMLEtBQUssTUFBTSxZQUFZLFVBQVUsS0FBSyxHQUFJO1FBQ3hDLFNBQVMsS0FBSyxDQUFDLElBQUksRUFBRTtNQUN2QjtJQUNGO0lBRUEsT0FBTztFQUNUO0VBRUE7Ozs7O0dBS0MsR0FDRCxBQUFPLFVBR0wsS0FBUyxFQUNtRDtJQUM1RCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRTtFQUN6QztBQUNGO0FBRUE7OztDQUdDLEdBQ0QsT0FBTyxNQUFNLHFCQUlIO0VBQ1I7Ozs7Ozs7O0dBUUMsR0FDRCxBQUFVLGFBQ1IsS0FBUyxFQUNULEdBQUcsSUFBcUMsRUFDL0I7SUFDVCxPQUFPLEtBQUssQ0FBQyxLQUFLLFVBQW9DO0VBQ3hEO0FBQ0YifQ==
// denoCacheMetadata=809920328164840202,5882423064440549914