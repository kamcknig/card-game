import { EventEmitter } from "../../event-emitter/mod.ts";
import { Packet, Parser, RawData } from "../../engine.io-parser/mod.ts";
import { getLogger } from "../../../deps.ts";
import { ServerOptions } from "./server.ts";

interface TransportEvents {
  packet: (packet: Packet) => void;
  error: (error: TransportError) => void;
  drain: () => void;
  close: () => void;
}

type ReadyState = "open" | "closing" | "closed";

export abstract class Transport extends EventEmitter<
  Record<never, never>,
  Record<never, never>,
  TransportEvents
> {
  public writable = false;

  protected readyState: ReadyState = "open";
  protected readonly opts: ServerOptions;

  constructor(opts: ServerOptions) {
    super();
    this.opts = opts;
  }

  /**
   * The name of the transport
   */
  public abstract get name(): string;

  /**
   * The list of transports to upgrade to
   */
  public abstract get upgradesTo(): string[];

  /**
   * Called with an incoming HTTP request.
   *
   * @param req
   * @param responseHeaders
   */
  public abstract onRequest(
    req: Request,
    responseHeaders: Headers,
  ): Promise<Response>;

  /**
   * Writes an array of packets.
   *
   * @param packets
   */
  public abstract send(packets: Packet[]): void;

  /**
   * Closes the transport.
   *
   * @protected
   */
  protected abstract doClose(): void;

  /**
   * Manually closes the transport.
   */
  public close() {
    if (["closing", "closed"].includes(this.readyState)) {
      return;
    }

    getLogger("engine.io").debug("[transport] closing transport");
    this.readyState = "closing";
    this.doClose();
  }

  /**
   * Called when the transport encounters a fatal error.
   *
   * @param message
   * @protected
   */
  protected onError(message: string) {
    this.emitReserved("error", new TransportError(message));
  }

  /**
   * Called with a parsed packet from the data stream.
   *
   * @param packet
   * @protected
   */
  protected onPacket(packet: Packet) {
    if (packet.type === "close") {
      getLogger("engine.io").debug("[transport] received 'close' packet");
      return this.doClose();
    }
    this.emitReserved("packet", packet);
  }

  /**
   * Called with the encoded packet data.
   *
   * @param data
   * @protected
   */
  protected onData(data: RawData) {
    this.onPacket(Parser.decodePacket(data));
  }

  /**
   * Called upon transport close.
   *
   * @protected
   */
  protected onClose() {
    this.readyState = "closed";
    this.emitReserved("close");
  }
}

export class TransportError extends Error {
  public readonly type = "TransportError";
}

// denoCacheMetadata={"headers":{"last-modified":"Thu, 09 Jan 2025 07:38:35 GMT","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox","cross-origin-resource-policy":"same-origin","access-control-allow-origin":"*","referrer-policy":"strict-origin-when-cross-origin","x-amz-cf-id":"N8fSd_7nAVjs8JuUjBd_nO-r-rKExAQ09QVfxD43ZIgP5EL_pA9kmw==","x-amz-replication-status":"COMPLETED","etag":"\"f918ddb169845158681d6fa42fc3a5df\"","strict-transport-security":"max-age=63072000; includeSubDomains; preload","cross-origin-opener-policy":"same-origin","x-amz-version-id":"20PMydhY6Q4.gK__vXy_q.Sw7A21bdGX","x-content-type-options":"nosniff","age":"12809340","content-length":"2604","server":"deno/gcp-us-east4","x-amz-cf-pop":"IAD61-P1","date":"Wed, 29 Jan 2025 15:36:35 GMT","vary":"Accept-Encoding, Origin","x-frame-options":"DENY","x-cache":"Hit from cloudfront","content-type":"application/typescript; charset=utf-8","cross-origin-embedder-policy":"same-origin","x-amz-server-side-encryption":"AES256","server-timing":"fetchSource;dur=36","via":"http/2 edgeproxy-h","cache-control":"public, max-age=31536000, immutable","accept-ranges":"bytes"},"url":"https://deno.land/x/socket_io@0.2.1/packages/engine.io/lib/transport.ts","time":1750974334}