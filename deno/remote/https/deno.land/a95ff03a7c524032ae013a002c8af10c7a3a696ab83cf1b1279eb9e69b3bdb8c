import { getLogger } from "../../../../deps.ts";
import { Transport } from "../transport.ts";
import { Packet, Parser } from "../../../engine.io-parser/mod.ts";

export class Polling extends Transport {
  private pollingPromise?: {
    resolve: (res: Response) => void;
    reject: () => void;
    responseHeaders: Headers;
  };

  public get name() {
    return "polling";
  }

  public get upgradesTo(): string[] {
    return ["websocket"];
  }

  public onRequest(req: Request, responseHeaders: Headers): Promise<Response> {
    if (req.method === "GET") {
      return this.onPollRequest(req, responseHeaders);
    } else if (req.method === "POST") {
      return this.onDataRequest(req, responseHeaders);
    }
    return Promise.resolve(
      new Response(null, { status: 400, headers: responseHeaders }),
    );
  }

  /**
   * The client sends a long-polling request awaiting the server to send data.
   *
   * @param req
   * @param responseHeaders
   * @private
   */
  private onPollRequest(
    _req: Request,
    responseHeaders: Headers,
  ): Promise<Response> {
    if (this.pollingPromise) {
      getLogger("engine.io").debug("[polling] request overlap");
      this.onError("overlap from client");
      return Promise.resolve(
        new Response(null, { status: 400, headers: responseHeaders }),
      );
    }

    getLogger("engine.io").debug(
      "[polling] new polling request",
    );

    return new Promise<Response>((resolve, reject) => {
      this.pollingPromise = { resolve, reject, responseHeaders };

      getLogger("engine.io").debug("[polling] transport is now writable");
      this.writable = true;
      this.emitReserved("drain");
    });
  }

  /**
   * The client sends a request with data.
   *
   * @param req
   * @param responseHeaders
   */
  private async onDataRequest(
    req: Request,
    responseHeaders: Headers,
  ): Promise<Response> {
    getLogger("engine.io").debug(
      "[polling] new data request",
    );

    const data = await req.text();

    if (data.length > this.opts.maxHttpBufferSize) {
      this.onError("payload too large");
      return Promise.resolve(
        new Response(null, { status: 413, headers: responseHeaders }),
      );
    }

    const packets = Parser.decodePayload(data);

    getLogger("engine.io").debug(
      `[polling] decoded ${packets.length} packet(s)`,
    );

    for (const packet of packets) {
      this.onPacket(packet);
    }

    return Promise.resolve(
      new Response("ok", {
        status: 200,
        headers: responseHeaders,
      }),
    );
  }

  public send(packets: Packet[]) {
    this.writable = false;
    Parser.encodePayload(packets, (data: string) => this.write(data));
  }

  /**
   * Writes data as response to long-polling request
   *
   * @param data
   * @private
   */
  private write(data: string) {
    getLogger("engine.io").debug(`[polling] writing ${data}`);

    if (!this.pollingPromise) {
      return;
    }

    const headers = this.pollingPromise.responseHeaders;
    headers.set("Content-Type", "text/plain; charset=UTF-8");

    // note: the HTTP server automatically handles the compression
    // see https://deno.land/manual@v1.24.3/runtime/http_server_apis#automatic-body-compression
    this.pollingPromise.resolve(
      new Response(data, {
        status: 200,
        headers,
      }),
    );

    this.pollingPromise = undefined;
  }

  protected doClose() {
    if (this.writable) {
      getLogger("engine.io").debug(
        "[polling] transport writable - closing right away",
      );
      // if we have received a "close" packet from the client, then we can just send a "noop" packet back
      this.send([{ type: this.readyState === "closing" ? "close" : "noop" }]);
    }

    this.onClose();
  }
}

// denoCacheMetadata={"headers":{"x-amz-cf-id":"t0i9Y-ZI_ssUAfWH6dsjC4YdToV-H7ZPLR2CuN1Ni27F3gozwIx7ug==","last-modified":"Thu, 09 Jan 2025 07:38:35 GMT","x-cache":"Hit from cloudfront","content-type":"application/typescript; charset=utf-8","age":"12809340","cross-origin-resource-policy":"same-origin","content-length":"3773","x-amz-server-side-encryption":"AES256","x-amz-version-id":"ZFPZbdAqqvcBMRRXaaYP9F9VBT1ZAaAw","x-content-type-options":"nosniff","x-frame-options":"DENY","cache-control":"public, max-age=31536000, immutable","server":"deno/gcp-us-east4","accept-ranges":"bytes","access-control-allow-origin":"*","etag":"\"44ddbddac205a30a219b3aac5bdd324d\"","server-timing":"fetchSource;dur=36","vary":"Accept-Encoding, Origin","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox","strict-transport-security":"max-age=63072000; includeSubDomains; preload","via":"http/2 edgeproxy-h","x-amz-cf-pop":"IAD61-P1","x-amz-replication-status":"COMPLETED","cross-origin-opener-policy":"same-origin","referrer-policy":"strict-origin-when-cross-origin","date":"Wed, 29 Jan 2025 15:36:35 GMT","cross-origin-embedder-policy":"same-origin"},"url":"https://deno.land/x/socket_io@0.2.1/packages/engine.io/lib/transports/polling.ts","time":1750974334}