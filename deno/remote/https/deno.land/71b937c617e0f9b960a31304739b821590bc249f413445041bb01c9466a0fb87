import type { Connection } from "./connection.ts";
import { CommandExecutor } from "./executor.ts";
import {
  okReply,
  RawOrError,
  RedisReply,
  RedisValue,
  sendCommands,
} from "./protocol/mod.ts";
import { create, Redis } from "./redis.ts";
import {
  Deferred,
  deferred,
} from "./vendor/https/deno.land/std/async/deferred.ts";

export interface RedisPipeline extends Redis {
  flush(): Promise<RawOrError[]>;
}

export function createRedisPipeline(
  connection: Connection,
  tx = false,
): RedisPipeline {
  const executor = new PipelineExecutor(connection, tx);
  function flush(): Promise<RawOrError[]> {
    return executor.flush();
  }
  const client = create(executor);
  return Object.assign(client, { flush });
}

export class PipelineExecutor implements CommandExecutor {
  private commands: {
    command: string;
    args: RedisValue[];
  }[] = [];
  private queue: {
    commands: {
      command: string;
      args: RedisValue[];
    }[];
    d: Deferred<RawOrError[]>;
  }[] = [];

  constructor(
    readonly connection: Connection,
    private tx: boolean,
  ) {
  }

  exec(
    command: string,
    ...args: RedisValue[]
  ): Promise<RedisReply> {
    this.commands.push({ command, args });
    return Promise.resolve(okReply);
  }

  close(): void {
    return this.connection.close();
  }

  flush(): Promise<RawOrError[]> {
    if (this.tx) {
      this.commands.unshift({ command: "MULTI", args: [] });
      this.commands.push({ command: "EXEC", args: [] });
    }
    const d = deferred<RawOrError[]>();
    this.queue.push({ commands: [...this.commands], d });
    if (this.queue.length === 1) {
      this.dequeue();
    }
    this.commands = [];
    return d;
  }

  private dequeue(): void {
    const [e] = this.queue;
    if (!e) return;
    sendCommands(this.connection.writer, this.connection.reader, e.commands)
      .then(e.d.resolve)
      .catch(e.d.reject)
      .finally(() => {
        this.queue.shift();
        this.dequeue();
      });
  }
}

// denoCacheMetadata={"headers":{"server-timing":"fetchSource;dur=12","content-length":"2001","strict-transport-security":"max-age=63072000; includeSubDomains; preload","content-type":"application/typescript; charset=utf-8","cross-origin-embedder-policy":"same-origin","x-amz-cf-pop":"IAD61-P1","x-frame-options":"DENY","x-amz-cf-id":"NI6XTQCjo7o76qLZ9ojggk_SDzI4QPw0-Rogn8y2UIbQIah8vWcL8g==","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox","cross-origin-resource-policy":"same-origin","x-amz-replication-status":"COMPLETED","x-content-type-options":"nosniff","x-amz-version-id":"4FaQRqlsOA9n6lVU0VmrgzGkRn22K9yj","age":"14542284","x-cache":"Hit from cloudfront","access-control-allow-origin":"*","cache-control":"public, max-age=31536000, immutable","referrer-policy":"strict-origin-when-cross-origin","via":"http/2 edgeproxy-h","etag":"\"e1a6b1f20a9302e647f8ca4055035734\"","vary":"Accept-Encoding, Origin","last-modified":"Thu, 09 Jan 2025 07:38:36 GMT","accept-ranges":"bytes","cross-origin-opener-policy":"same-origin","date":"Thu, 09 Jan 2025 14:14:10 GMT","server":"deno/gcp-us-east4","x-amz-server-side-encryption":"AES256"},"url":"https://deno.land/x/socket_io@0.2.1/vendor/deno.land/x/redis@v0.27.1/pipeline.ts","time":1750974332}