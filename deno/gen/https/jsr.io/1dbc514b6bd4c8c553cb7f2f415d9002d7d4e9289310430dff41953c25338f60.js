/**
 * Combines multiple arrays into a single array of tuples.
 *
 * This function takes multiple arrays and returns a new array where each element is a tuple
 * containing the corresponding elements from the input arrays. If the input arrays are of
 * different lengths, the resulting array will have the length of the longest input array,
 * with undefined values for missing elements.
 *
 * @template T
 * @param {T[]} arr1 - The first array to zip.
 * @returns {Array<[T]>} A new array of tuples containing the corresponding elements from the input arrays.
 *
 * @example
 * const arr1 = [1, 2, 3];
 * const result = zip(arr1);
 * // result will be [[1], [2], [3]]
 */ /**
 * Combines multiple arrays into a single array of tuples.
 *
 * This function takes multiple arrays and returns a new array where each element is a tuple
 * containing the corresponding elements from the input arrays. If the input arrays are of
 * different lengths, the resulting array will have the length of the longest input array,
 * with undefined values for missing elements.
 *
 * @template T
 * @param {...Array<readonly T[]>} arrs - The arrays to zip together.
 * @returns {T[][]} A new array of tuples containing the corresponding elements from the input arrays.
 *
 * @example
 * const arr1 = [1, 2, 3];
 * const arr2 = ['a', 'b', 'c'];
 * const arr3 = [true, false];
 * const result = zip(arr1, arr2, arr3);
 * // result will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]
 */ export function zip(...arrs) {
  // For performance reasons, use this implementation instead of
  // const rowCount = Math.max(...arrs.map(x => x.length));
  let rowCount = 0;
  for(let i = 0; i < arrs.length; i++){
    if (arrs[i].length > rowCount) {
      rowCount = arrs[i].length;
    }
  }
  const columnCount = arrs.length;
  const result = Array(rowCount);
  for(let i = 0; i < rowCount; ++i){
    const row = Array(columnCount);
    for(let j = 0; j < columnCount; ++j){
      row[j] = arrs[j][i];
    }
    result[i] = row;
  }
  return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vanNyLmlvL0Blcy10b29sa2l0L2VzLXRvb2xraXQvMS4zMy4wL3NyYy9hcnJheS96aXAudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBhcnJheXMgaW50byBhIHNpbmdsZSBhcnJheSBvZiB0dXBsZXMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBtdWx0aXBsZSBhcnJheXMgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgd2hlcmUgZWFjaCBlbGVtZW50IGlzIGEgdHVwbGVcbiAqIGNvbnRhaW5pbmcgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQgYXJyYXlzLiBJZiB0aGUgaW5wdXQgYXJyYXlzIGFyZSBvZlxuICogZGlmZmVyZW50IGxlbmd0aHMsIHRoZSByZXN1bHRpbmcgYXJyYXkgd2lsbCBoYXZlIHRoZSBsZW5ndGggb2YgdGhlIGxvbmdlc3QgaW5wdXQgYXJyYXksXG4gKiB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgZm9yIG1pc3NpbmcgZWxlbWVudHMuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VFtdfSBhcnIxIC0gVGhlIGZpcnN0IGFycmF5IHRvIHppcC5cbiAqIEByZXR1cm5zIHtBcnJheTxbVF0+fSBBIG5ldyBhcnJheSBvZiB0dXBsZXMgY29udGFpbmluZyB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBhcnJheXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGFycjEgPSBbMSwgMiwgM107XG4gKiBjb25zdCByZXN1bHQgPSB6aXAoYXJyMSk7XG4gKiAvLyByZXN1bHQgd2lsbCBiZSBbWzFdLCBbMl0sIFszXV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHppcDxUPihhcnIxOiByZWFkb25seSBUW10pOiBBcnJheTxbVF0+O1xuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIGFycmF5cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIHR1cGxlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIG11bHRpcGxlIGFycmF5cyBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgYSB0dXBsZVxuICogY29udGFpbmluZyB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBhcnJheXMuIElmIHRoZSBpbnB1dCBhcnJheXMgYXJlIG9mXG4gKiBkaWZmZXJlbnQgbGVuZ3RocywgdGhlIHJlc3VsdGluZyBhcnJheSB3aWxsIGhhdmUgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBpbnB1dCBhcnJheSxcbiAqIHdpdGggdW5kZWZpbmVkIHZhbHVlcyBmb3IgbWlzc2luZyBlbGVtZW50cy5cbiAqXG4gKiBAdGVtcGxhdGUgVCwgVVxuICogQHBhcmFtIHtUW119IGFycjEgLSBUaGUgZmlyc3QgYXJyYXkgdG8gemlwLlxuICogQHBhcmFtIHtVW119IGFycjIgLSBUaGUgc2Vjb25kIGFycmF5IHRvIHppcC5cbiAqIEByZXR1cm5zIHtBcnJheTxbVCwgVV0+fSBBIG5ldyBhcnJheSBvZiB0dXBsZXMgY29udGFpbmluZyB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBhcnJheXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGFycjEgPSBbMSwgMiwgM107XG4gKiBjb25zdCBhcnIyID0gWydhJywgJ2InLCAnYyddO1xuICogY29uc3QgcmVzdWx0ID0gemlwKGFycjEsIGFycjIpO1xuICogLy8gcmVzdWx0IHdpbGwgYmUgW1sxLCAnYSddLCBbMiwgJ2InXSwgWzMsICdjJ11dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6aXA8VCwgVT4oYXJyMTogcmVhZG9ubHkgVFtdLCBhcnIyOiByZWFkb25seSBVW10pOiBBcnJheTxbVCwgVV0+O1xuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIGFycmF5cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIHR1cGxlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIG11bHRpcGxlIGFycmF5cyBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgYSB0dXBsZVxuICogY29udGFpbmluZyB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBhcnJheXMuIElmIHRoZSBpbnB1dCBhcnJheXMgYXJlIG9mXG4gKiBkaWZmZXJlbnQgbGVuZ3RocywgdGhlIHJlc3VsdGluZyBhcnJheSB3aWxsIGhhdmUgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBpbnB1dCBhcnJheSxcbiAqIHdpdGggdW5kZWZpbmVkIHZhbHVlcyBmb3IgbWlzc2luZyBlbGVtZW50cy5cbiAqXG4gKiBAdGVtcGxhdGUgVCwgVSwgVlxuICogQHBhcmFtIHtUW119IGFycjEgLSBUaGUgZmlyc3QgYXJyYXkgdG8gemlwLlxuICogQHBhcmFtIHtVW119IGFycjIgLSBUaGUgc2Vjb25kIGFycmF5IHRvIHppcC5cbiAqIEBwYXJhbSB7VltdfSBhcnIzIC0gVGhlIHRoaXJkIGFycmF5IHRvIHppcC5cbiAqIEByZXR1cm5zIHtBcnJheTxbVCwgVSwgVl0+fSBBIG5ldyBhcnJheSBvZiB0dXBsZXMgY29udGFpbmluZyB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBhcnJheXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGFycjEgPSBbMSwgMiwgM107XG4gKiBjb25zdCBhcnIyID0gWydhJywgJ2InLCAnYyddO1xuICogY29uc3QgYXJyMyA9IFt0cnVlLCBmYWxzZV07XG4gKiBjb25zdCByZXN1bHQgPSB6aXAoYXJyMSwgYXJyMiwgYXJyMyk7XG4gKiAvLyByZXN1bHQgd2lsbCBiZSBbWzEsICdhJywgdHJ1ZV0sIFsyLCAnYicsIGZhbHNlXSwgWzMsICdjJywgdW5kZWZpbmVkXV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHppcDxULCBVLCBWPihhcnIxOiByZWFkb25seSBUW10sIGFycjI6IHJlYWRvbmx5IFVbXSwgYXJyMzogcmVhZG9ubHkgVltdKTogQXJyYXk8W1QsIFUsIFZdPjtcblxuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBhcnJheXMgaW50byBhIHNpbmdsZSBhcnJheSBvZiB0dXBsZXMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBtdWx0aXBsZSBhcnJheXMgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgd2hlcmUgZWFjaCBlbGVtZW50IGlzIGEgdHVwbGVcbiAqIGNvbnRhaW5pbmcgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQgYXJyYXlzLiBJZiB0aGUgaW5wdXQgYXJyYXlzIGFyZSBvZlxuICogZGlmZmVyZW50IGxlbmd0aHMsIHRoZSByZXN1bHRpbmcgYXJyYXkgd2lsbCBoYXZlIHRoZSBsZW5ndGggb2YgdGhlIGxvbmdlc3QgaW5wdXQgYXJyYXksXG4gKiB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgZm9yIG1pc3NpbmcgZWxlbWVudHMuXG4gKlxuICogQHRlbXBsYXRlIFQsIFUsIFYsIFdcbiAqIEBwYXJhbSB7VFtdfSBhcnIxIC0gVGhlIGZpcnN0IGFycmF5IHRvIHppcC5cbiAqIEBwYXJhbSB7VVtdfSBhcnIyIC0gVGhlIHNlY29uZCBhcnJheSB0byB6aXAuXG4gKiBAcGFyYW0ge1ZbXX0gYXJyMyAtIFRoZSB0aGlyZCBhcnJheSB0byB6aXAuXG4gKiBAcGFyYW0ge1dbXX0gYXJyNCAtIFRoZSBmb3VydGggYXJyYXkgdG8gemlwLlxuICogQHJldHVybnMge0FycmF5PFtULCBVLCBWLCBXXT59IEEgbmV3IGFycmF5IG9mIHR1cGxlcyBjb250YWluaW5nIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnRzIGZyb20gdGhlIGlucHV0IGFycmF5cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYXJyMSA9IFsxLCAyLCAzXTtcbiAqIGNvbnN0IGFycjIgPSBbJ2EnLCAnYicsICdjJ107XG4gKiBjb25zdCBhcnIzID0gW3RydWUsIGZhbHNlXTtcbiAqIGNvbnN0IGFycjQgPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gKiBjb25zdCByZXN1bHQgPSB6aXAoYXJyMSwgYXJyMiwgYXJyMywgYXJyNCk7XG4gKiAvLyByZXN1bHQgd2lsbCBiZSBbWzEsICdhJywgdHJ1ZSwgbnVsbF0sIFsyLCAnYicsIGZhbHNlLCBudWxsXSwgWzMsICdjJywgdW5kZWZpbmVkLCBudWxsXV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHppcDxULCBVLCBWLCBXPihcbiAgYXJyMTogcmVhZG9ubHkgVFtdLFxuICBhcnIyOiByZWFkb25seSBVW10sXG4gIGFycjM6IHJlYWRvbmx5IFZbXSxcbiAgYXJyNDogcmVhZG9ubHkgV1tdXG4pOiBBcnJheTxbVCwgVSwgViwgV10+O1xuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIGFycmF5cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIHR1cGxlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIG11bHRpcGxlIGFycmF5cyBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgYSB0dXBsZVxuICogY29udGFpbmluZyB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dCBhcnJheXMuIElmIHRoZSBpbnB1dCBhcnJheXMgYXJlIG9mXG4gKiBkaWZmZXJlbnQgbGVuZ3RocywgdGhlIHJlc3VsdGluZyBhcnJheSB3aWxsIGhhdmUgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBpbnB1dCBhcnJheSxcbiAqIHdpdGggdW5kZWZpbmVkIHZhbHVlcyBmb3IgbWlzc2luZyBlbGVtZW50cy5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsuLi5BcnJheTxyZWFkb25seSBUW10+fSBhcnJzIC0gVGhlIGFycmF5cyB0byB6aXAgdG9nZXRoZXIuXG4gKiBAcmV0dXJucyB7VFtdW119IEEgbmV3IGFycmF5IG9mIHR1cGxlcyBjb250YWluaW5nIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnRzIGZyb20gdGhlIGlucHV0IGFycmF5cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYXJyMSA9IFsxLCAyLCAzXTtcbiAqIGNvbnN0IGFycjIgPSBbJ2EnLCAnYicsICdjJ107XG4gKiBjb25zdCBhcnIzID0gW3RydWUsIGZhbHNlXTtcbiAqIGNvbnN0IHJlc3VsdCA9IHppcChhcnIxLCBhcnIyLCBhcnIzKTtcbiAqIC8vIHJlc3VsdCB3aWxsIGJlIFtbMSwgJ2EnLCB0cnVlXSwgWzIsICdiJywgZmFsc2VdLCBbMywgJ2MnLCB1bmRlZmluZWRdXVxuICovXG5leHBvcnQgZnVuY3Rpb24gemlwPFQ+KC4uLmFycnM6IEFycmF5PHJlYWRvbmx5IFRbXT4pOiBUW11bXSB7XG4gIC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB1c2UgdGhpcyBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkIG9mXG4gIC8vIGNvbnN0IHJvd0NvdW50ID0gTWF0aC5tYXgoLi4uYXJycy5tYXAoeCA9PiB4Lmxlbmd0aCkpO1xuICBsZXQgcm93Q291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJycy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJzW2ldLmxlbmd0aCA+IHJvd0NvdW50KSB7XG4gICAgICByb3dDb3VudCA9IGFycnNbaV0ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb2x1bW5Db3VudCA9IGFycnMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBBcnJheShyb3dDb3VudCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgKytpKSB7XG4gICAgY29uc3Qgcm93ID0gQXJyYXkoY29sdW1uQ291bnQpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uQ291bnQ7ICsraikge1xuICAgICAgcm93W2pdID0gYXJyc1tqXVtpXTtcbiAgICB9XG4gICAgcmVzdWx0W2ldID0gcm93O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0E2RUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNELE9BQU8sU0FBUyxJQUFPLEdBQUcsSUFBeUI7RUFDakQsOERBQThEO0VBQzlELHlEQUF5RDtFQUN6RCxJQUFJLFdBQVc7RUFFZixJQUFLLElBQUksSUFBSSxHQUFHLElBQUksS0FBSyxNQUFNLEVBQUUsSUFBSztJQUNwQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxHQUFHLFVBQVU7TUFDN0IsV0FBVyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU07SUFDM0I7RUFDRjtFQUNBLE1BQU0sY0FBYyxLQUFLLE1BQU07RUFDL0IsTUFBTSxTQUFTLE1BQU07RUFFckIsSUFBSyxJQUFJLElBQUksR0FBRyxJQUFJLFVBQVUsRUFBRSxFQUFHO0lBQ2pDLE1BQU0sTUFBTSxNQUFNO0lBQ2xCLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxhQUFhLEVBQUUsRUFBRztNQUNwQyxHQUFHLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUNyQjtJQUNBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7RUFDZDtFQUNBLE9BQU87QUFDVCJ9
// denoCacheMetadata=5876299185392285135,2517838077371859337