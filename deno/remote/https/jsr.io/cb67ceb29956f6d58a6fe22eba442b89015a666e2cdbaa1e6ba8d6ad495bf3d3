// deno-lint-ignore-file no-explicit-any

import * as dt from 'jsr:@std/datetime@0.224.3'

type LogLevel = 'error' | 'warn' | 'log' | 'info' | 'debug' | 'timer' | 'func'
type LogConfig = {
	// Special format specifiers
	// {T}: time, current local time formated by `timeFormat`
	// {l}: log level in lowercase
	// {L}: log level in uppercase
	// {C}: multi-line connector
	prefixFormat: string,

	// the format of the time part in the prefix
	// see https://deno.land/std/datetime/mod.ts for more information
	timeFormat: string,

	// how to align the level string in the prefix
	levelAlignment: 'left' | 'right' | 'none',

	prefixEmptyLines: boolean,
	enabledLevels: LogLevel[],
	indentSize: number,
	colors: Record<LogLevel, string>
}

function getDefaultConsoleConfig() : LogConfig {
	return {
		prefixFormat: '[{T}]{C}[{L}] ',
		timeFormat: 'MM-dd HH:mm:ss.SSS',
		levelAlignment: 'right',
		enabledLevels: ['error', 'warn', 'info', 'log', 'timer', 'func', 'debug'],
		prefixEmptyLines: false,
		indentSize: 2,
		colors: {error: 'red', warn: 'yellow', log: 'lightgray', info: 'blue', debug: 'gray', timer: 'green', func: 'purple'}
	}
}
function getDefaultFileConfig() : LogConfig {
	return {
		prefixFormat: '[{T}]{C}[{L}] ',
		timeFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
		levelAlignment: 'right',
		enabledLevels: ['error', 'warn', 'info', 'log', 'timer', 'func', 'debug'],
		prefixEmptyLines: false,
		indentSize: 4,
		colors: {error: 'red', warn: 'yellow', log: 'lightgray', info: 'blue', debug: 'gray', timer: 'green', func: 'purple'}
	}
}

let fileLogger: Deno.FsFile
const consoleConfig = getDefaultConsoleConfig()
const fileConfig = getDefaultFileConfig()
const rawConsole = {...globalThis.console}
const timers: Record<string, number> = {}
let currentIndent = 0

export function init() {
	for (const k of ['error', 'warn', 'log', 'info', 'debug'] as const) {
		globalThis.console[k] = (...data: any[]) => timestampedLeveledLog(k, data)
	}
	
	globalThis.console.time = (label = 'default') => {
		if (timers[label])
			return console.warn(`Timer ${label} already exists.`, timers)
		timers[label] = performance.now()
	}
	globalThis.console.timeLog = (label = 'default', ...data: any[]) => {
		const logTime = performance.now()
		const startTime = timers[label]
		if (!startTime)
			return console.warn(`Timer ${label} doesn't exist.`, timers)
		timestampedLeveledLog('timer', [`${label}: ${(logTime - startTime).toLocaleString(undefined, { maximumFractionDigits: 0 })}ms`, ...data])
	}
	globalThis.console.timeEnd = (label = 'default') => {
		const endTime = performance.now()
		const startTime = timers[label]
		if (!startTime)
			return console.warn(`Timer ${label} doesn't exist.`, timers)
		timestampedLeveledLog('timer', [`${label}: ${(endTime - startTime).toLocaleString(undefined, { maximumFractionDigits: 0 })}ms - timer ended`])
		delete timers[label]
	}
}

function getFileLogger() {
	if (fileLogger) return fileLogger

	const name = Deno.mainModule.replace(/.*\/([^\\]+)\.ts$/, '$1')
	try { Deno.statSync('./logs/') } catch { Deno.mkdirSync('./logs/') }
	fileLogger = Deno.createSync(`./logs/${name}-${dt.format(new Date, 'yyyyMMdd-HHmmss')}.log`)
	return fileLogger
}

function timestampedLeveledLog (level: LogLevel, data: any[]) {
	// count '%c' in a string but ignore '%%c'
	const findColorSpecifiers = (s: string) => {
		const r = []
		for (let i = 0; i < s.length - 1; ++i) {
			if (s[i] === '%' && s[i + 1] === 'c' && (i === 0 || s[i - 1] !== '%'))
				r.push(i)
		}
		return r
	}

	const removeColorSpecifiers = (s: string, removeLimit: number) => {
		const cs = findColorSpecifiers(s).slice(0, removeLimit)
		let r = ''
		let p = 0
		for (const c of cs) {
			r += s.slice(p, c)
			p = c + 2
		}
		r += s.slice(p)
		return r
	}

	const breakDataToColoredLines = (data: any[]) => {
		const formatParams = (data: any[]) => {
			const records = []
			for (let i = 0; i < data.length; ++i)
				records.push((typeof data[i] === 'string') ? data[i] : Deno.inspect(data[i]))
			return records.join(' ')
		}

		if (data.length === 0) data = ['']
		let fi = 1
		const cls: {l: string, colors: string[]}[] = []
		if (typeof data[0] === 'string') {
			const lines = data[0].split('\n')
			for (const l of lines) {
				const c = findColorSpecifiers(l).length
				cls.push({l, colors: data.slice(fi, fi + c)})
				fi += c
			}
		} else {
			cls.push(...formatParams([data[0]]).split('\n').map(l => ({l, colors: []})))
		}
	
		if (fi < data.length) {
			const remainingLines = formatParams(data.slice(fi)).split('\n')
			cls[cls.length - 1].l += ' '+ remainingLines.shift()
			for (const l of remainingLines) {
				cls.push({ l, colors: [] })
			}
		}

		return cls
	}

	const computeLogLines = (lines: {l: string, colors: string[]}[], cfg: LogConfig) => {
		const skipPrefix = data.length === 0 && cfg.prefixEmptyLines === false
		const dateStr = dt.format(new Date(), cfg.timeFormat)
		const alignFuncs = {
			left: (s: string) => s.padEnd(5, ' '),
			right: (s: string) => s.padStart(5, ' '),
			none: (s: string) => s
		}
		const levelStr = alignFuncs[cfg.levelAlignment](level)
		const indent = ' '.repeat(currentIndent * cfg.indentSize)
		const levelColor = `color:${cfg.colors[level]}`
		let currentUserColorFormat = levelColor
		const logs = []
		const colors = []
		for (let i = 0; i < lines.length; ++i) {
			const l = lines[i]
			const connector = lines.length === 1 ? '─' : (i === 0 ? '┬' : i === lines.length - 1 ? '└' : '├')
			if (skipPrefix) {
				logs.push(l.l)
				colors.push(...l.colors)
			} else {
				const prefix = cfg.prefixFormat
					.replaceAll('{T}', dateStr)
					.replaceAll('{l}', levelStr)
					.replaceAll('{L}', levelStr.toUpperCase())
					.replaceAll('{C}', connector)
				logs.push(`%c${prefix}%c${indent}` + l.l)
				colors.push(levelColor, currentUserColorFormat, ...l.colors)
			}
			if (l.colors.length > 0) currentUserColorFormat = l.colors[l.colors.length - 1]
		}
		return {logs, colors}
	}

	const outputToConsole = consoleConfig.enabledLevels.includes(level)
	const outputToFile = fileConfig.enabledLevels.includes(level)
	if (!outputToConsole && !outputToFile) return

	const lines = breakDataToColoredLines(data)
	
	if (outputToConsole) {
		const {logs, colors} = computeLogLines(lines, consoleConfig)
		rawConsole[level === 'timer' || level === 'func'? 'log' : level](logs.join('\n'), ...colors)
	}

	if (outputToFile) {
		const {logs, colors} = computeLogLines(lines, fileConfig)
		const file = getFileLogger()
		file.write(new TextEncoder().encode(removeColorSpecifiers(logs.join('\n'), colors.length) + '\n'))
	}
}

/** Set log config
 * @param config new config
 * @param applyTo file or console or all
 */
export function setConfig(config: Partial<LogConfig>, applyTo: 'console' | 'file' | 'all' = 'all') {
	if (applyTo === 'all' || applyTo === 'console') Object.assign(consoleConfig, config)
	if (applyTo === 'all' || applyTo === 'file') Object.assign(fileConfig, config)
}

/**
 * Set log enabled levels to >= the specified level, as the following order:
 * - error
 * - warn
 * - info
 * - log = timer = func
 * - debug
 * @param level expected log level
 * @param applyTo file or console or all
 */
export function setLogLevel(level: 'error' | 'warn' | 'info' | 'log' | 'debug', applyTo: 'console' | 'file' | 'all' = 'all') {
	const levels: LogLevel[] = ['debug', 'log', 'func', 'timer', 'info', 'warn', 'error']
	const index = levels.indexOf(level)
	const enabledLevels = levels.slice(index)
	setConfig({enabledLevels}, applyTo)
}

/**
 * This function need to be called by `using` statement.
 * It will issue a log "xxx enters" with 'info' level immediately, and a log 
 * "xxx leaves" will be automatically issued when current scope ends
 * All other logs issued in this scope will be promoted using spaces by 1 indent level
 * @example
  * function init() {
 *   using x = traceScope('Init')
 *   ...
 *   console.log('another log inside init')
 *   ...
 * }
 */
export function traceScope(name: string, context = '', leaveLog = false, level: LogLevel = 'info') : { [Symbol.dispose](): void } {
	const contextText = context ? ` (${context})` : ''
	timestampedLeveledLog(level, [`${name} enters${contextText}`])
	currentIndent++
	return { [Symbol.dispose](){
		currentIndent--
		if (leaveLog) timestampedLeveledLog(level, [`${name} leaves`])
	}}
}

/**
 * This function need to be called by `using` statement. 
 * It will issue a log "${funcName} called" with 'func' level immediately, and a log
 * 
 */
export function traceFunction(args: IArguments|null = null, leaveLog = false) : { [Symbol.dispose](): void } {
	const l = new Error().stack?.split('\n')[2]
	const name = l?.match(/at (.+) \(/)?.[1] || l?.match(/\/([^\/]+)$/)?.[1] || 'anonymous'
	return traceScope(name, args ? 'args: ' + JSON.stringify([...args]) : '', leaveLog, 'func')
}

/**
 * Get the raw console object in case you need to use the original console
 */
export const raw = rawConsole

// denoCacheMetadata={"headers":{"x-jsr-cache-status":"revalidated","access-control-allow-origin":"*","x-goog-stored-content-length":"8939","x-goog-stored-content-encoding":"identity","content-type":"text/typescript","x-goog-generation":"1734523922204752","date":"Thu, 26 Jun 2025 21:45:35 GMT","x-goog-hash":"crc32c=GkPPLg==,md5=/F0VFpD7EClQ/qttJONzaQ==","expires":"Fri, 26 Jun 2026 21:45:35 GMT","x-content-type-options":"nosniff","etag":"\"fc5d151690fb102950feab6d24e37369\"","alt-svc":"h3=\":443\"; ma=2592000,h3-29=\":443\"; ma=2592000","accept-ranges":"bytes","access-control-expose-headers":"*","cache-control":"public, max-age=31536000, immutable","content-length":"8939","x-jsr-cache-id":"ATL","cross-origin-resource-policy":"cross-origin","x-guploader-uploadid":"ABgVH88yK5pB3Qq5eaBGI6Cyg66uRRRBYuTiD80ejirQZo46BfdTODYk6h1Hx88_Yfed463JH4jay4E","server":"UploadServer","via":"1.1 google","x-robots-tag":"noindex","content-security-policy":"default-src 'none'; script-src 'none'; style-src 'none'; img-src 'none'; font-src 'none'; connect-src 'none'; frame-src 'none'; object-src 'none'; frame-ancestors 'none'; sandbox; form-action 'none';","x-goog-metageneration":"1","x-goog-storage-class":"STANDARD","last-modified":"Wed, 18 Dec 2024 12:12:02 GMT","age":"0"},"url":"https://jsr.io/@timepp/enhanced-deno-log/0.4.1/log.ts","time":1750974334}