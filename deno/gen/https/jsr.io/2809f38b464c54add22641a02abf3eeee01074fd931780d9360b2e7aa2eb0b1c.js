import { identity } from '../../function/identity.ts';
import { isNil } from '../../predicate/isNil.ts';
/**
 * Creates a new object that reverses the keys and values of the given object, similar to the invert.
 *
 * The `iteratee` function specifies how the values are reversed into keys. If no `iteratee` function is provided, the values are used as keys as-is.
 *
 * The values of the new object are arrays of keys that correspond to the value returned by the `iteratee` function.
 *
 * @param {Record<K, V>} object - The object to iterate over.
 * @param {(value: V) => string} [iteratee] - Optional. A function that generates a key based on each value in the object.
 * If not provided, the function defaults to using the value as a string.
 *
 * @returns {Record<string, K[]>} An object where the keys are generated by the iteratee, and the values
 * are arrays of property names (keys) from the input object that correspond to those keys.
 *
 * @example
 * const obj = { a: 1, b: 2, c: 1 };
 * const result = invertBy(obj);
 * // result => { '1': ['a', 'c'], '2': ['b'] }
 *
 * @example
 * const obj = { a: 1, b: 2, c: 1 };
 * const result = invertBy(obj, value => `group${value}`);
 * // result => { 'group1': ['a', 'c'], 'group2': ['b'] }
 */ export function invertBy(object, iteratee) {
  const result = {};
  if (isNil(object)) {
    return result;
  }
  if (iteratee == null) {
    iteratee = identity;
  }
  const keys = Object.keys(object);
  for(let i = 0; i < keys.length; i++){
    const key = keys[i];
    const value = object[key];
    const valueStr = iteratee(value);
    if (Array.isArray(result[valueStr])) {
      result[valueStr].push(key);
    } else {
      result[valueStr] = [
        key
      ];
    }
  }
  return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vanNyLmlvL0Blcy10b29sa2l0L2VzLXRvb2xraXQvMS4zMy4wL3NyYy9jb21wYXQvb2JqZWN0L2ludmVydEJ5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlkZW50aXR5IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb24vaWRlbnRpdHkudHMnO1xuaW1wb3J0IHsgaXNOaWwgfSBmcm9tICcuLi8uLi9wcmVkaWNhdGUvaXNOaWwudHMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgcmV2ZXJzZXMgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LCBzaW1pbGFyIHRvIHRoZSBpbnZlcnQuXG4gKlxuICogVGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24gc3BlY2lmaWVzIGhvdyB0aGUgdmFsdWVzIGFyZSByZXZlcnNlZCBpbnRvIGtleXMuIElmIG5vIGBpdGVyYXRlZWAgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHRoZSB2YWx1ZXMgYXJlIHVzZWQgYXMga2V5cyBhcy1pcy5cbiAqXG4gKiBUaGUgdmFsdWVzIG9mIHRoZSBuZXcgb2JqZWN0IGFyZSBhcnJheXMgb2Yga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UmVjb3JkPEssIFY+fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7KHZhbHVlOiBWKSA9PiBzdHJpbmd9IFtpdGVyYXRlZV0gLSBPcHRpb25hbC4gQSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIGtleSBiYXNlZCBvbiBlYWNoIHZhbHVlIGluIHRoZSBvYmplY3QuXG4gKiBJZiBub3QgcHJvdmlkZWQsIHRoZSBmdW5jdGlvbiBkZWZhdWx0cyB0byB1c2luZyB0aGUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIEtbXT59IEFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBpdGVyYXRlZSwgYW5kIHRoZSB2YWx1ZXNcbiAqIGFyZSBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMgKGtleXMpIGZyb20gdGhlIGlucHV0IG9iamVjdCB0aGF0IGNvcnJlc3BvbmQgdG8gdGhvc2Uga2V5cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb2JqID0geyBhOiAxLCBiOiAyLCBjOiAxIH07XG4gKiBjb25zdCByZXN1bHQgPSBpbnZlcnRCeShvYmopO1xuICogLy8gcmVzdWx0ID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb2JqID0geyBhOiAxLCBiOiAyLCBjOiAxIH07XG4gKiBjb25zdCByZXN1bHQgPSBpbnZlcnRCeShvYmosIHZhbHVlID0+IGBncm91cCR7dmFsdWV9YCk7XG4gKiAvLyByZXN1bHQgPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydEJ5PEsgZXh0ZW5kcyBQcm9wZXJ0eUtleSwgVj4oXG4gIG9iamVjdDogUmVjb3JkPEssIFY+LFxuICBpdGVyYXRlZT86ICh2YWx1ZTogVikgPT4gc3RyaW5nXG4pOiBSZWNvcmQ8c3RyaW5nLCBLW10+IHtcbiAgY29uc3QgcmVzdWx0ID0ge30gYXMgUmVjb3JkPHN0cmluZywgS1tdPjtcblxuICBpZiAoaXNOaWwob2JqZWN0KSkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCkge1xuICAgIGl0ZXJhdGVlID0gaWRlbnRpdHkgYXMgKHZhbHVlOiBWKSA9PiBzdHJpbmc7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldIGFzIEs7XG5cbiAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIGNvbnN0IHZhbHVlU3RyID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W3ZhbHVlU3RyXSkpIHtcbiAgICAgIHJlc3VsdFt2YWx1ZVN0cl0ucHVzaChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRbdmFsdWVTdHJdID0gW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLFFBQVEsUUFBUSw2QkFBNkI7QUFDdEQsU0FBUyxLQUFLLFFBQVEsMkJBQTJCO0FBRWpEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVCQyxHQUNELE9BQU8sU0FBUyxTQUNkLE1BQW9CLEVBQ3BCLFFBQStCO0VBRS9CLE1BQU0sU0FBUyxDQUFDO0VBRWhCLElBQUksTUFBTSxTQUFTO0lBQ2pCLE9BQU87RUFDVDtFQUVBLElBQUksWUFBWSxNQUFNO0lBQ3BCLFdBQVc7RUFDYjtFQUVBLE1BQU0sT0FBTyxPQUFPLElBQUksQ0FBQztFQUV6QixJQUFLLElBQUksSUFBSSxHQUFHLElBQUksS0FBSyxNQUFNLEVBQUUsSUFBSztJQUNwQyxNQUFNLE1BQU0sSUFBSSxDQUFDLEVBQUU7SUFFbkIsTUFBTSxRQUFRLE1BQU0sQ0FBQyxJQUFJO0lBQ3pCLE1BQU0sV0FBVyxTQUFTO0lBRTFCLElBQUksTUFBTSxPQUFPLENBQUMsTUFBTSxDQUFDLFNBQVMsR0FBRztNQUNuQyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQztJQUN4QixPQUFPO01BQ0wsTUFBTSxDQUFDLFNBQVMsR0FBRztRQUFDO09BQUk7SUFDMUI7RUFDRjtFQUVBLE9BQU87QUFDVCJ9
// denoCacheMetadata=10467286588181992994,15106140685417636442