import { decodeFromBase64, encodeToBase64 } from "./base64-arraybuffer.ts";
const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const PACKET_TYPES = new Map();
const PACKET_TYPES_REVERSE = new Map();
[
  "open",
  "close",
  "ping",
  "pong",
  "message",
  "upgrade",
  "noop"
].forEach((type, index)=>{
  PACKET_TYPES.set(type, "" + index);
  PACKET_TYPES_REVERSE.set("" + index, type);
});
const ERROR_PACKET = {
  type: "error",
  data: "parser error"
};
export const Parser = {
  encodePacket ({ type, data }, supportsBinary, callback) {
    if (data instanceof Blob) {
      return supportsBinary ? callback(data) : encodeBlobAsBase64(data, callback);
    } else if (data instanceof ArrayBuffer) {
      return callback(supportsBinary ? data : "b" + encodeToBase64(data));
    } else if (ArrayBuffer.isView(data)) {
      if (supportsBinary) {
        return callback(data);
      } else {
        const array = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        return callback("b" + encodeToBase64(array));
      }
    }
    // plain string
    return callback(PACKET_TYPES.get(type) + (data || ""));
  },
  decodePacket (encodedPacket, binaryType) {
    if (typeof encodedPacket !== "string") {
      return {
        type: "message",
        data: mapBinary(encodedPacket, binaryType)
      };
    }
    const typeChar = encodedPacket.charAt(0);
    if (typeChar === "b") {
      const buffer = decodeFromBase64(encodedPacket.substring(1));
      return {
        type: "message",
        data: mapBinary(buffer, binaryType)
      };
    }
    if (!PACKET_TYPES_REVERSE.has(typeChar)) {
      return ERROR_PACKET;
    }
    const type = PACKET_TYPES_REVERSE.get(typeChar);
    return encodedPacket.length > 1 ? {
      type,
      data: encodedPacket.substring(1)
    } : {
      type
    };
  },
  encodePayload (packets, callback) {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i)=>{
      // force base64 encoding for binary packets
      this.encodePacket(packet, false, (encodedPacket)=>{
        encodedPackets[i] = encodedPacket;
        if (++count === length) {
          callback(encodedPackets.join(SEPARATOR));
        }
      });
    });
  },
  decodePayload (encodedPayload, binaryType) {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for(let i = 0; i < encodedPackets.length; i++){
      const decodedPacket = this.decodePacket(encodedPackets[i], binaryType);
      packets.push(decodedPacket);
      if (decodedPacket.type === "error") {
        break;
      }
    }
    return packets;
  }
};
function encodeBlobAsBase64(data, callback) {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + content);
  };
  return fileReader.readAsDataURL(data);
}
function mapBinary(data, binaryType) {
  switch(binaryType){
    case "blob":
      return new Blob([
        data
      ]);
    case "arraybuffer":
    default:
      return data; // assuming the data is already an ArrayBuffer
  }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvc29ja2V0X2lvQDAuMi4xL3BhY2thZ2VzL2VuZ2luZS5pby1wYXJzZXIvbW9kLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlY29kZUZyb21CYXNlNjQsIGVuY29kZVRvQmFzZTY0IH0gZnJvbSBcIi4vYmFzZTY0LWFycmF5YnVmZmVyLnRzXCI7XG5cbmNvbnN0IFNFUEFSQVRPUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzApOyAvLyBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVsaW1pdGVyI0FTQ0lJX2RlbGltaXRlZF90ZXh0XG5cbmV4cG9ydCB0eXBlIFBhY2tldFR5cGUgPVxuICB8IFwib3BlblwiXG4gIHwgXCJjbG9zZVwiXG4gIHwgXCJwaW5nXCJcbiAgfCBcInBvbmdcIlxuICB8IFwibWVzc2FnZVwiXG4gIHwgXCJ1cGdyYWRlXCJcbiAgfCBcIm5vb3BcIlxuICB8IFwiZXJyb3JcIjtcblxuZXhwb3J0IHR5cGUgUmF3RGF0YSA9IHN0cmluZyB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3IHwgQmxvYjtcblxuZXhwb3J0IGludGVyZmFjZSBQYWNrZXQge1xuICB0eXBlOiBQYWNrZXRUeXBlO1xuICBkYXRhPzogUmF3RGF0YTtcbn1cblxuY29uc3QgUEFDS0VUX1RZUEVTID0gbmV3IE1hcDxQYWNrZXRUeXBlLCBzdHJpbmc+KCk7XG5jb25zdCBQQUNLRVRfVFlQRVNfUkVWRVJTRSA9IG5ldyBNYXA8c3RyaW5nLCBQYWNrZXRUeXBlPigpO1xuXG4oW1xuICBcIm9wZW5cIixcbiAgXCJjbG9zZVwiLFxuICBcInBpbmdcIixcbiAgXCJwb25nXCIsXG4gIFwibWVzc2FnZVwiLFxuICBcInVwZ3JhZGVcIixcbiAgXCJub29wXCIsXG5dIGFzIFBhY2tldFR5cGVbXSkuZm9yRWFjaCgodHlwZSwgaW5kZXgpID0+IHtcbiAgUEFDS0VUX1RZUEVTLnNldCh0eXBlLCBcIlwiICsgaW5kZXgpO1xuICBQQUNLRVRfVFlQRVNfUkVWRVJTRS5zZXQoXCJcIiArIGluZGV4LCB0eXBlKTtcbn0pO1xuXG5jb25zdCBFUlJPUl9QQUNLRVQ6IFBhY2tldCA9IHsgdHlwZTogXCJlcnJvclwiLCBkYXRhOiBcInBhcnNlciBlcnJvclwiIH07XG5cbnR5cGUgQmluYXJ5VHlwZSA9IFwiYXJyYXlidWZmZXJcIiB8IFwiYmxvYlwiO1xuXG5leHBvcnQgY29uc3QgUGFyc2VyID0ge1xuICBlbmNvZGVQYWNrZXQoXG4gICAgeyB0eXBlLCBkYXRhIH06IFBhY2tldCxcbiAgICBzdXBwb3J0c0JpbmFyeTogYm9vbGVhbixcbiAgICBjYWxsYmFjazogKGVuY29kZWRQYWNrZXQ6IFJhd0RhdGEpID0+IHZvaWQsXG4gICkge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgcmV0dXJuIHN1cHBvcnRzQmluYXJ5XG4gICAgICAgID8gY2FsbGJhY2soZGF0YSlcbiAgICAgICAgOiBlbmNvZGVCbG9iQXNCYXNlNjQoZGF0YSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soc3VwcG9ydHNCaW5hcnkgPyBkYXRhIDogXCJiXCIgKyBlbmNvZGVUb0Jhc2U2NChkYXRhKSk7XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgIGlmIChzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgIGRhdGEuYnVmZmVyLFxuICAgICAgICAgIGRhdGEuYnl0ZU9mZnNldCxcbiAgICAgICAgICBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhcImJcIiArIGVuY29kZVRvQmFzZTY0KGFycmF5KSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHBsYWluIHN0cmluZ1xuICAgIHJldHVybiBjYWxsYmFjayhQQUNLRVRfVFlQRVMuZ2V0KHR5cGUpICsgKGRhdGEgfHwgXCJcIikpO1xuICB9LFxuXG4gIGRlY29kZVBhY2tldChcbiAgICBlbmNvZGVkUGFja2V0OiBSYXdEYXRhLFxuICAgIGJpbmFyeVR5cGU/OiBCaW5hcnlUeXBlLFxuICApOiBQYWNrZXQge1xuICAgIGlmICh0eXBlb2YgZW5jb2RlZFBhY2tldCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJtZXNzYWdlXCIsXG4gICAgICAgIGRhdGE6IG1hcEJpbmFyeShlbmNvZGVkUGFja2V0LCBiaW5hcnlUeXBlKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHR5cGVDaGFyID0gZW5jb2RlZFBhY2tldC5jaGFyQXQoMCk7XG4gICAgaWYgKHR5cGVDaGFyID09PSBcImJcIikge1xuICAgICAgY29uc3QgYnVmZmVyID0gZGVjb2RlRnJvbUJhc2U2NChlbmNvZGVkUGFja2V0LnN1YnN0cmluZygxKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgZGF0YTogbWFwQmluYXJ5KGJ1ZmZlciwgYmluYXJ5VHlwZSksXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIVBBQ0tFVF9UWVBFU19SRVZFUlNFLmhhcyh0eXBlQ2hhcikpIHtcbiAgICAgIHJldHVybiBFUlJPUl9QQUNLRVQ7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBQQUNLRVRfVFlQRVNfUkVWRVJTRS5nZXQodHlwZUNoYXIpITtcbiAgICByZXR1cm4gZW5jb2RlZFBhY2tldC5sZW5ndGggPiAxXG4gICAgICA/IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZGF0YTogZW5jb2RlZFBhY2tldC5zdWJzdHJpbmcoMSksXG4gICAgICB9XG4gICAgICA6IHtcbiAgICAgICAgdHlwZSxcbiAgICAgIH07XG4gIH0sXG5cbiAgZW5jb2RlUGF5bG9hZChcbiAgICBwYWNrZXRzOiBQYWNrZXRbXSxcbiAgICBjYWxsYmFjazogKGVuY29kZWRQYXlsb2FkOiBzdHJpbmcpID0+IHZvaWQsXG4gICkge1xuICAgIC8vIHNvbWUgcGFja2V0cyBtYXkgYmUgYWRkZWQgdG8gdGhlIGFycmF5IHdoaWxlIGVuY29kaW5nLCBzbyB0aGUgaW5pdGlhbCBsZW5ndGggbXVzdCBiZSBzYXZlZFxuICAgIGNvbnN0IGxlbmd0aCA9IHBhY2tldHMubGVuZ3RoO1xuICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIHBhY2tldHMuZm9yRWFjaCgocGFja2V0LCBpKSA9PiB7XG4gICAgICAvLyBmb3JjZSBiYXNlNjQgZW5jb2RpbmcgZm9yIGJpbmFyeSBwYWNrZXRzXG4gICAgICB0aGlzLmVuY29kZVBhY2tldChwYWNrZXQsIGZhbHNlLCAoZW5jb2RlZFBhY2tldCkgPT4ge1xuICAgICAgICBlbmNvZGVkUGFja2V0c1tpXSA9IGVuY29kZWRQYWNrZXQ7XG4gICAgICAgIGlmICgrK2NvdW50ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBjYWxsYmFjayhlbmNvZGVkUGFja2V0cy5qb2luKFNFUEFSQVRPUikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICBkZWNvZGVQYXlsb2FkKFxuICAgIGVuY29kZWRQYXlsb2FkOiBzdHJpbmcsXG4gICAgYmluYXJ5VHlwZT86IEJpbmFyeVR5cGUsXG4gICk6IFBhY2tldFtdIHtcbiAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IGVuY29kZWRQYXlsb2FkLnNwbGl0KFNFUEFSQVRPUik7XG4gICAgY29uc3QgcGFja2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlY29kZWRQYWNrZXQgPSB0aGlzLmRlY29kZVBhY2tldChlbmNvZGVkUGFja2V0c1tpXSwgYmluYXJ5VHlwZSk7XG4gICAgICBwYWNrZXRzLnB1c2goZGVjb2RlZFBhY2tldCk7XG4gICAgICBpZiAoZGVjb2RlZFBhY2tldC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYWNrZXRzO1xuICB9LFxufTtcblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQmFzZTY0KFxuICBkYXRhOiBCbG9iLFxuICBjYWxsYmFjazogKGVuY29kZWRQYWNrZXQ6IFJhd0RhdGEpID0+IHZvaWQsXG4pIHtcbiAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSAoZmlsZVJlYWRlci5yZXN1bHQgYXMgc3RyaW5nKS5zcGxpdChcIixcIilbMV07XG4gICAgY2FsbGJhY2soXCJiXCIgKyBjb250ZW50KTtcbiAgfTtcbiAgcmV0dXJuIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChkYXRhKTtcbn1cblxuZnVuY3Rpb24gbWFwQmluYXJ5KGRhdGE6IFJhd0RhdGEsIGJpbmFyeVR5cGU/OiBCaW5hcnlUeXBlKSB7XG4gIHN3aXRjaCAoYmluYXJ5VHlwZSkge1xuICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICByZXR1cm4gbmV3IEJsb2IoW2RhdGFdKTtcbiAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGE7IC8vIGFzc3VtaW5nIHRoZSBkYXRhIGlzIGFscmVhZHkgYW4gQXJyYXlCdWZmZXJcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFNBQVMsZ0JBQWdCLEVBQUUsY0FBYyxRQUFRLDBCQUEwQjtBQUUzRSxNQUFNLFlBQVksT0FBTyxZQUFZLENBQUMsS0FBSyxtRUFB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
// denoCacheMetadata=3579665943120649422,13976070778558829433