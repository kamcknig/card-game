import type { CommandExecutor } from "./executor.ts";
import { InvalidStateError } from "./errors.ts";
import { readArrayReplyBody } from "./protocol/mod.ts";
import { decoder } from "./protocol/_util.ts";

type DefaultMessageType = string;
type ValidMessageType = string | string[] | Uint8Array;

export interface RedisSubscription<
  TMessage extends ValidMessageType = DefaultMessageType,
> {
  readonly isClosed: boolean;
  receive(): AsyncIterableIterator<RedisPubSubMessage<TMessage>>;
  receiveBinary(): AsyncIterableIterator<RedisPubSubMessage<TMessage>>;
  psubscribe(...patterns: string[]): Promise<void>;
  subscribe(...channels: string[]): Promise<void>;
  punsubscribe(...patterns: string[]): Promise<void>;
  unsubscribe(...channels: string[]): Promise<void>;
  close(): void;
}

export interface RedisPubSubMessage<TMessage = DefaultMessageType> {
  pattern?: string;
  channel: string;
  message: TMessage;
}

class RedisSubscriptionImpl<
  TMessage extends ValidMessageType = DefaultMessageType,
> implements RedisSubscription<TMessage> {
  get isConnected(): boolean {
    return this.executor.connection.isConnected;
  }

  get isClosed(): boolean {
    return this.executor.connection.isClosed;
  }

  private channels = Object.create(null);
  private patterns = Object.create(null);

  constructor(private executor: CommandExecutor) {}

  async psubscribe(...patterns: string[]) {
    await this.executor.exec("PSUBSCRIBE", ...patterns);
    for (const pat of patterns) {
      this.patterns[pat] = true;
    }
  }

  async punsubscribe(...patterns: string[]) {
    await this.executor.exec("PUNSUBSCRIBE", ...patterns);
    for (const pat of patterns) {
      delete this.patterns[pat];
    }
  }

  async subscribe(...channels: string[]) {
    await this.executor.exec("SUBSCRIBE", ...channels);
    for (const chan of channels) {
      this.channels[chan] = true;
    }
  }

  async unsubscribe(...channels: string[]) {
    await this.executor.exec("UNSUBSCRIBE", ...channels);
    for (const chan of channels) {
      delete this.channels[chan];
    }
  }

  receive(): AsyncIterableIterator<RedisPubSubMessage<TMessage>> {
    return this.#_receive();
  }

  receiveBinary(): AsyncIterableIterator<RedisPubSubMessage<TMessage>> {
    return this.#_receive(true);
  }

  async *#_receive(
    binary = false,
  ): AsyncIterableIterator<RedisPubSubMessage<TMessage>> {
    let forceReconnect = false;
    const connection = this.executor.connection;
    while (this.isConnected) {
      try {
        let rep: [string, string, Uint8Array] | [
          string,
          string,
          string,
          Uint8Array,
        ];
        try {
          rep = (await readArrayReplyBody(connection.reader)) as [
            string,
            string,
            Uint8Array,
          ] | [string, string, string, Uint8Array];
        } catch (err) {
          if (err instanceof Deno.errors.BadResource) {
            // Connection already closed.
            connection.close();
            break;
          }
          throw err;
        }
        const ev = rep[0];

        if (ev === "message" && rep.length === 3) {
          yield {
            channel: rep[1],
            message: (binary ? rep[2] : decoder.decode(rep[2])) as TMessage,
          };
        } else if (ev === "pmessage" && rep.length === 4) {
          yield {
            pattern: rep[1],
            channel: rep[2],
            message: (binary ? rep[3] : decoder.decode(rep[3])) as TMessage,
          };
        }
      } catch (error) {
        if (
          error instanceof InvalidStateError ||
          error instanceof Deno.errors.BadResource
        ) {
          forceReconnect = true;
        } else throw error;
      } finally {
        if ((!this.isClosed && !this.isConnected) || forceReconnect) {
          await connection.reconnect();
          forceReconnect = false;

          if (Object.keys(this.channels).length > 0) {
            await this.subscribe(...Object.keys(this.channels));
          }
          if (Object.keys(this.patterns).length > 0) {
            await this.psubscribe(...Object.keys(this.patterns));
          }
        }
      }
    }
  }

  close() {
    this.executor.connection.close();
  }
}

export async function subscribe<
  TMessage extends ValidMessageType = DefaultMessageType,
>(
  executor: CommandExecutor,
  ...channels: string[]
): Promise<RedisSubscription<TMessage>> {
  const sub = new RedisSubscriptionImpl<TMessage>(executor);
  await sub.subscribe(...channels);
  return sub;
}

export async function psubscribe<
  TMessage extends ValidMessageType = DefaultMessageType,
>(
  executor: CommandExecutor,
  ...patterns: string[]
): Promise<RedisSubscription<TMessage>> {
  const sub = new RedisSubscriptionImpl<TMessage>(executor);
  await sub.psubscribe(...patterns);
  return sub;
}

// denoCacheMetadata={"headers":{"x-amz-cf-pop":"IAD61-P1","x-amz-version-id":"PQrygnjrlx.eVq1C39603Oj2Y3A6sjBI","etag":"\"b7602d57488839641da120e403760e73\"","vary":"Accept-Encoding, Origin","x-content-type-options":"nosniff","access-control-allow-origin":"*","strict-transport-security":"max-age=63072000; includeSubDomains; preload","cache-control":"public, max-age=31536000, immutable","cross-origin-resource-policy":"same-origin","server-timing":"fetchSource;dur=12","cross-origin-embedder-policy":"same-origin","referrer-policy":"strict-origin-when-cross-origin","age":"14542284","x-amz-cf-id":"uEVA_71-mBjHwKVmp-IEBj2QM_luL6DBy2LpNkN3t7JmQrzDo8nhzg==","server":"deno/gcp-us-east4","accept-ranges":"bytes","via":"http/2 edgeproxy-h","content-length":"4851","last-modified":"Thu, 09 Jan 2025 07:38:36 GMT","x-amz-replication-status":"COMPLETED","x-amz-server-side-encryption":"AES256","x-cache":"Hit from cloudfront","content-type":"application/typescript; charset=utf-8","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox","x-frame-options":"DENY","cross-origin-opener-policy":"same-origin","date":"Thu, 09 Jan 2025 14:14:10 GMT"},"url":"https://deno.land/x/socket_io@0.2.1/vendor/deno.land/x/redis@v0.27.1/pubsub.ts","time":1750974332}