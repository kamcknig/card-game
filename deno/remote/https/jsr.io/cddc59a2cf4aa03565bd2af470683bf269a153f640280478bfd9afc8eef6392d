/**
 * Creates a function that invokes the method at `object[key]` with `partialArgs` prepended to the arguments it receives.
 *
 * This method differs from `bind` by allowing bound functions to reference methods that may be redefined or don't yet exist.
 *
 * The `bindKey.placeholder` value, which defaults to a `symbol`, may be used as a placeholder for partially applied arguments.
 *
 * @template T - The type of the object to bind.
 * @template K - The type of the key to bind.
 * @param {T} object - The object to invoke the method on.
 * @param {K} key - The key of the method.
 * @param {...any} partialArgs - The arguments to be partially applied.
 * @returns {T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never} - Returns the new bound function.
 *
 * @example
 * const object = {
 *   user: 'fred',
 *   greet: function (greeting, punctuation) {
 *     return greeting + ' ' + this.user + punctuation;
 *   },
 * };
 *
 * let bound = bindKey(object, 'greet', 'hi');
 * bound('!');
 * // => 'hi fred!'
 *
 * object.greet = function (greeting, punctuation) {
 *   return greeting + 'ya ' + this.user + punctuation;
 * };
 *
 * bound('!');
 * // => 'hiya fred!'
 *
 * // Bound with placeholders.
 * bound = bindKey(object, 'greet', bindKey.placeholder, '!');
 * bound('hi');
 * // => 'hiya fred!'
 */
export function bindKey<T extends Record<PropertyKey, any>, K extends keyof T>(
  object: T,
  key: K,
  ...partialArgs: any[]
): T[K] extends (...args: any[]) => any ? (...args: any[]) => ReturnType<T[K]> : never {
  const bound = function (this: any, ...providedArgs: any[]) {
    const args: any[] = [];

    // Populate args by merging partialArgs and providedArgs.
    // e.g.. when we call bind(func, {}, [1, bind.placeholder, 3])(2, 4);
    // we have args with [1, 2, 3, 4].
    let startIndex = 0;

    for (let i = 0; i < partialArgs.length; i++) {
      const arg = partialArgs[i];

      if (arg === bindKey.placeholder) {
        args.push(providedArgs[startIndex++]);
      } else {
        args.push(arg);
      }
    }

    for (let i = startIndex; i < providedArgs.length; i++) {
      args.push(providedArgs[i]);
    }

    if (this instanceof bound) {
      return new object[key](...args);
    }

    // eslint-disable-next-line prefer-spread
    return object[key].apply(object, args);
  };

  return bound as any;
}

const bindKeyPlaceholder: unique symbol = Symbol('bindKey.placeholder');
bindKey.placeholder = bindKeyPlaceholder;

// denoCacheMetadata={"headers":{"x-goog-generation":"1741509575305141","last-modified":"Sun, 09 Mar 2025 08:39:35 GMT","accept-ranges":"bytes","access-control-expose-headers":"*","content-type":"text/typescript","content-length":"2497","x-robots-tag":"noindex","cross-origin-resource-policy":"cross-origin","x-guploader-uploadid":"ABgVH89EJpg0ktetYMHVeowW5E5-Cc0ac9Gy-xme_KtP7PJpqpu_dcNGHkMqQdCoqdn3r-qoX5Fbb48","x-goog-stored-content-encoding":"identity","server":"UploadServer","age":"0","x-jsr-cache-id":"ATL","date":"Thu, 26 Jun 2025 21:45:35 GMT","x-jsr-cache-status":"revalidated","x-goog-metageneration":"1","etag":"\"21f538ca266dde1d86006df8b4dae07d\"","access-control-allow-origin":"*","cache-control":"public, max-age=31536000, immutable","x-content-type-options":"nosniff","x-goog-hash":"crc32c=nRua9A==,md5=IfU4yiZt3h2GAG34tNrgfQ==","via":"1.1 google","content-security-policy":"default-src 'none'; script-src 'none'; style-src 'none'; img-src 'none'; font-src 'none'; connect-src 'none'; frame-src 'none'; object-src 'none'; frame-ancestors 'none'; sandbox; form-action 'none';","x-goog-stored-content-length":"2497","x-goog-storage-class":"STANDARD","alt-svc":"h3=\":443\"; ma=2592000,h3-29=\":443\"; ma=2592000","expires":"Fri, 26 Jun 2026 21:45:35 GMT"},"url":"https://jsr.io/@es-toolkit/es-toolkit/1.33.0/src/compat/function/bindKey.ts","time":1750974334}