import { debounce } from './debounce.ts';
/**
 * Creates a throttled function that only invokes the provided function at most once
 * per every `throttleMs` milliseconds. Subsequent calls to the throttled function
 * within the wait time will not trigger the execution of the original function.
 *
 * @template F - The type of function.
 * @param {F} func - The function to throttle.
 * @param {number} throttleMs - The number of milliseconds to throttle executions to.
 * @param {ThrottleOptions} options - The options object
 * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the throttled function.
 * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.
 * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.
 * @returns {(...args: Parameters<F>) => void} A new throttled function that accepts the same parameters as the original function.
 *
 * @example
 * const throttledFunction = throttle(() => {
 *   console.log('Function executed');
 * }, 1000);
 *
 * // Will log 'Function executed' immediately
 * throttledFunction();
 *
 * // Will not log anything as it is within the throttle time
 * throttledFunction();
 *
 * // After 1 second
 * setTimeout(() => {
 *   throttledFunction(); // Will log 'Function executed'
 * }, 1000);
 */ export function throttle(func, throttleMs = 0, options = {}) {
  if (typeof options !== 'object') {
    options = {};
  }
  const { leading = true, trailing = true, signal } = options;
  return debounce(func, throttleMs, {
    leading,
    trailing,
    signal,
    maxWait: throttleMs
  });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vanNyLmlvL0Blcy10b29sa2l0L2VzLXRvb2xraXQvMS4zMy4wL3NyYy9jb21wYXQvZnVuY3Rpb24vdGhyb3R0bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVib3VuY2UsIHR5cGUgRGVib3VuY2VkRnVuY3Rpb24gfSBmcm9tICcuL2RlYm91bmNlLnRzJztcblxuaW50ZXJmYWNlIFRocm90dGxlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBBYm9ydFNpZ25hbCB0byBjYW5jZWwgdGhlIGZ1bmN0aW9uIGludm9jYXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAqL1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbDtcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGxlYWRpbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHRyYWlsaW5nPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBhdCBtb3N0IG9uY2VcbiAqIHBlciBldmVyeSBgdGhyb3R0bGVNc2AgbWlsbGlzZWNvbmRzLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIHdpdGhpbiB0aGUgd2FpdCB0aW1lIHdpbGwgbm90IHRyaWdnZXIgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gKlxuICogQHRlbXBsYXRlIEYgLSBUaGUgdHlwZSBvZiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Rn0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aHJvdHRsZU1zIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgZXhlY3V0aW9ucyB0by5cbiAqIEBwYXJhbSB7VGhyb3R0bGVPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBvcHRpb25zLnNpZ25hbCAtIEFuIG9wdGlvbmFsIEFib3J0U2lnbmFsIHRvIGNhbmNlbCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlYWRpbmcgLSBJZiBgdHJ1ZWAsIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy50cmFpbGluZyAtIElmIGB0cnVlYCwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHsoLi4uYXJnczogUGFyYW1ldGVyczxGPikgPT4gdm9pZH0gQSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgdGhyb3R0bGVkRnVuY3Rpb24gPSB0aHJvdHRsZSgoKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdGdW5jdGlvbiBleGVjdXRlZCcpO1xuICogfSwgMTAwMCk7XG4gKlxuICogLy8gV2lsbCBsb2cgJ0Z1bmN0aW9uIGV4ZWN1dGVkJyBpbW1lZGlhdGVseVxuICogdGhyb3R0bGVkRnVuY3Rpb24oKTtcbiAqXG4gKiAvLyBXaWxsIG5vdCBsb2cgYW55dGhpbmcgYXMgaXQgaXMgd2l0aGluIHRoZSB0aHJvdHRsZSB0aW1lXG4gKiB0aHJvdHRsZWRGdW5jdGlvbigpO1xuICpcbiAqIC8vIEFmdGVyIDEgc2Vjb25kXG4gKiBzZXRUaW1lb3V0KCgpID0+IHtcbiAqICAgdGhyb3R0bGVkRnVuY3Rpb24oKTsgLy8gV2lsbCBsb2cgJ0Z1bmN0aW9uIGV4ZWN1dGVkJ1xuICogfSwgMTAwMCk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZTxGIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuICBmdW5jOiBGLFxuICB0aHJvdHRsZU1zID0gMCxcbiAgb3B0aW9uczogVGhyb3R0bGVPcHRpb25zID0ge31cbik6IERlYm91bmNlZEZ1bmN0aW9uPEY+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHsgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZSwgc2lnbmFsIH0gPSBvcHRpb25zO1xuXG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB0aHJvdHRsZU1zLCB7XG4gICAgbGVhZGluZyxcbiAgICB0cmFpbGluZyxcbiAgICBzaWduYWwsXG4gICAgbWF4V2FpdDogdGhyb3R0bGVNcyxcbiAgfSk7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxRQUFRLFFBQWdDLGdCQUFnQjtBQXFCakU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkJDLEdBQ0QsT0FBTyxTQUFTLFNBQ2QsSUFBTyxFQUNQLGFBQWEsQ0FBQyxFQUNkLFVBQTJCLENBQUMsQ0FBQztFQUU3QixJQUFJLE9BQU8sWUFBWSxVQUFVO0lBQy9CLFVBQVUsQ0FBQztFQUNiO0VBRUEsTUFBTSxFQUFFLFVBQVUsSUFBSSxFQUFFLFdBQVcsSUFBSSxFQUFFLE1BQU0sRUFBRSxHQUFHO0VBRXBELE9BQU8sU0FBUyxNQUFNLFlBQVk7SUFDaEM7SUFDQTtJQUNBO0lBQ0EsU0FBUztFQUNYO0FBQ0YifQ==
// denoCacheMetadata=7244848167178384580,2213584139353352153