import { debounce } from './debounce.ts';
/**
 * Creates a throttled function that only invokes the provided function at most once
 * per every `throttleMs` milliseconds. Subsequent calls to the throttled function
 * within the wait time will not trigger the execution of the original function.
 *
 * @template F - The type of function.
 * @param {F} func - The function to throttle.
 * @param {number} throttleMs - The number of milliseconds to throttle executions to.
 * @returns {(...args: Parameters<F>) => void} A new throttled function that accepts the same parameters as the original function.
 *
 * @example
 * const throttledFunction = throttle(() => {
 *   console.log('Function executed');
 * }, 1000);
 *
 * // Will log 'Function executed' immediately
 * throttledFunction();
 *
 * // Will not log anything as it is within the throttle time
 * throttledFunction();
 *
 * // After 1 second
 * setTimeout(() => {
 *   throttledFunction(); // Will log 'Function executed'
 * }, 1000);
 */ export function throttle(func, throttleMs, { signal, edges = [
  'leading',
  'trailing'
] } = {}) {
  let pendingAt = null;
  const debounced = debounce(func, throttleMs, {
    signal,
    edges
  });
  const throttled = function(...args) {
    if (pendingAt == null) {
      pendingAt = Date.now();
    } else {
      if (Date.now() - pendingAt >= throttleMs) {
        pendingAt = Date.now();
        debounced.cancel();
        debounced(...args);
      }
    }
    debounced(...args);
  };
  throttled.cancel = debounced.cancel;
  throttled.flush = debounced.flush;
  return throttled;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vanNyLmlvL0Blcy10b29sa2l0L2VzLXRvb2xraXQvMS4zMy4wL3NyYy9mdW5jdGlvbi90aHJvdHRsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJy4vZGVib3VuY2UudHMnO1xuXG5pbnRlcmZhY2UgVGhyb3R0bGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIEFib3J0U2lnbmFsIHRvIGNhbmNlbCB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbmFsPzogQWJvcnRTaWduYWw7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIGFycmF5IHNwZWNpZnlpbmcgd2hldGhlciB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgZWRnZSwgdHJhaWxpbmcgZWRnZSwgb3IgYm90aC5cbiAgICogSWYgYGVkZ2VzYCBpbmNsdWRlcyBcImxlYWRpbmdcIiwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIGRlbGF5IHBlcmlvZC5cbiAgICogSWYgYGVkZ2VzYCBpbmNsdWRlcyBcInRyYWlsaW5nXCIsIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYXQgdGhlIGVuZCBvZiB0aGUgZGVsYXkgcGVyaW9kLlxuICAgKiBJZiBib3RoIFwibGVhZGluZ1wiIGFuZCBcInRyYWlsaW5nXCIgYXJlIGluY2x1ZGVkLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGF0IGJvdGggdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGRlbGF5IHBlcmlvZC5cbiAgICogQGRlZmF1bHQgW1wibGVhZGluZ1wiLCBcInRyYWlsaW5nXCJdXG4gICAqL1xuICBlZGdlcz86IEFycmF5PCdsZWFkaW5nJyB8ICd0cmFpbGluZyc+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocm90dGxlZEZ1bmN0aW9uPEYgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IHZvaWQ+IHtcbiAgKC4uLmFyZ3M6IFBhcmFtZXRlcnM8Rj4pOiB2b2lkO1xuICBjYW5jZWw6ICgpID0+IHZvaWQ7XG4gIGZsdXNoOiAoKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGF0IG1vc3Qgb25jZVxuICogcGVyIGV2ZXJ5IGB0aHJvdHRsZU1zYCBtaWxsaXNlY29uZHMuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogd2l0aGluIHRoZSB3YWl0IHRpbWUgd2lsbCBub3QgdHJpZ2dlciB0aGUgZXhlY3V0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgRiAtIFRoZSB0eXBlIG9mIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGfSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRocm90dGxlTXMgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBleGVjdXRpb25zIHRvLlxuICogQHJldHVybnMgeyguLi5hcmdzOiBQYXJhbWV0ZXJzPEY+KSA9PiB2b2lkfSBBIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB0aHJvdHRsZWRGdW5jdGlvbiA9IHRocm90dGxlKCgpID0+IHtcbiAqICAgY29uc29sZS5sb2coJ0Z1bmN0aW9uIGV4ZWN1dGVkJyk7XG4gKiB9LCAxMDAwKTtcbiAqXG4gKiAvLyBXaWxsIGxvZyAnRnVuY3Rpb24gZXhlY3V0ZWQnIGltbWVkaWF0ZWx5XG4gKiB0aHJvdHRsZWRGdW5jdGlvbigpO1xuICpcbiAqIC8vIFdpbGwgbm90IGxvZyBhbnl0aGluZyBhcyBpdCBpcyB3aXRoaW4gdGhlIHRocm90dGxlIHRpbWVcbiAqIHRocm90dGxlZEZ1bmN0aW9uKCk7XG4gKlxuICogLy8gQWZ0ZXIgMSBzZWNvbmRcbiAqIHNldFRpbWVvdXQoKCkgPT4ge1xuICogICB0aHJvdHRsZWRGdW5jdGlvbigpOyAvLyBXaWxsIGxvZyAnRnVuY3Rpb24gZXhlY3V0ZWQnXG4gKiB9LCAxMDAwKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlPEYgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IHZvaWQ+KFxuICBmdW5jOiBGLFxuICB0aHJvdHRsZU1zOiBudW1iZXIsXG4gIHsgc2lnbmFsLCBlZGdlcyA9IFsnbGVhZGluZycsICd0cmFpbGluZyddIH06IFRocm90dGxlT3B0aW9ucyA9IHt9XG4pOiBUaHJvdHRsZWRGdW5jdGlvbjxGPiB7XG4gIGxldCBwZW5kaW5nQXQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0IGRlYm91bmNlZCA9IGRlYm91bmNlKGZ1bmMsIHRocm90dGxlTXMsIHsgc2lnbmFsLCBlZGdlcyB9KTtcblxuICBjb25zdCB0aHJvdHRsZWQgPSBmdW5jdGlvbiAoLi4uYXJnczogUGFyYW1ldGVyczxGPikge1xuICAgIGlmIChwZW5kaW5nQXQgPT0gbnVsbCkge1xuICAgICAgcGVuZGluZ0F0ID0gRGF0ZS5ub3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKERhdGUubm93KCkgLSBwZW5kaW5nQXQgPj0gdGhyb3R0bGVNcykge1xuICAgICAgICBwZW5kaW5nQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICBkZWJvdW5jZWQuY2FuY2VsKCk7XG4gICAgICAgIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH07XG5cbiAgdGhyb3R0bGVkLmNhbmNlbCA9IGRlYm91bmNlZC5jYW5jZWw7XG4gIHRocm90dGxlZC5mbHVzaCA9IGRlYm91bmNlZC5mbHVzaDtcblxuICByZXR1cm4gdGhyb3R0bGVkO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFNBQVMsUUFBUSxRQUFRLGdCQUFnQjtBQXdCekM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDRCxPQUFPLFNBQVMsU0FDZCxJQUFPLEVBQ1AsVUFBa0IsRUFDbEIsRUFBRSxNQUFNLEVBQUUsUUFBUTtFQUFDO0VBQVc7Q0FBVyxFQUFtQixHQUFHLENBQUMsQ0FBQztFQUVqRSxJQUFJLFlBQTJCO0VBRS9CLE1BQU0sWUFBWSxTQUFTLE1BQU0sWUFBWTtJQUFFO0lBQVE7RUFBTTtFQUU3RCxNQUFNLFlBQVksU0FBVSxHQUFHLElBQW1CO0lBQ2hELElBQUksYUFBYSxNQUFNO01BQ3JCLFlBQVksS0FBSyxHQUFHO0lBQ3RCLE9BQU87TUFDTCxJQUFJLEtBQUssR0FBRyxLQUFLLGFBQWEsWUFBWTtRQUN4QyxZQUFZLEtBQUssR0FBRztRQUNwQixVQUFVLE1BQU07UUFDaEIsYUFBYTtNQUNmO0lBQ0Y7SUFFQSxhQUFhO0VBQ2Y7RUFFQSxVQUFVLE1BQU0sR0FBRyxVQUFVLE1BQU07RUFDbkMsVUFBVSxLQUFLLEdBQUcsVUFBVSxLQUFLO0VBRWpDLE9BQU87QUFDVCJ9
// denoCacheMetadata=6694572957018116523,520128075495898275