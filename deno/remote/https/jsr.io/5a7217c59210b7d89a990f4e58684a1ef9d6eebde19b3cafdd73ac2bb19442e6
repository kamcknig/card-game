/**
 * A counting semaphore for async functions that manages available permits.
 * Semaphores are mainly used to limit the number of concurrent async tasks.
 *
 * Each `acquire` operation takes a permit or waits until one is available.
 * Each `release` operation adds a permit, potentially allowing a waiting task to proceed.
 *
 * The semaphore ensures fairness by maintaining a FIFO (First In, First Out) order for acquirers.
 *
 * @example
 * const sema = new Semaphore(2);
 *
 * async function task() {
 *   await sema.acquire();
 *   try {
 *     // This code can only be executed by two tasks at the same time
 *   } finally {
 *     sema.release();
 *   }
 * }
 *
 * task();
 * task();
 * task(); // This task will wait until one of the previous tasks releases the semaphore.
 */
export class Semaphore {
  /**
   * The maximum number of concurrent operations allowed.
   * @type {number}
   */
  public capacity: number;

  /**
   * The number of available permits.
   * @type {number}
   */
  public available: number;
  private deferredTasks: Array<() => void> = [];

  /**
   * Creates an instance of Semaphore.
   * @param {number} capacity - The maximum number of concurrent operations allowed.
   *
   * @example
   * const sema = new Semaphore(3); // Allows up to 3 concurrent operations.
   */
  constructor(capacity: number) {
    this.capacity = capacity;
    this.available = capacity;
  }

  /**
   * Acquires a semaphore, blocking if necessary until one is available.
   * @returns {Promise<void>} A promise that resolves when the semaphore is acquired.
   *
   * @example
   * const sema = new Semaphore(1);
   *
   * async function criticalSection() {
   *   await sema.acquire();
   *   try {
   *     // This code section cannot be executed simultaneously
   *   } finally {
   *     sema.release();
   *   }
   * }
   */
  async acquire(): Promise<void> {
    if (this.available > 0) {
      this.available--;
      return;
    }

    return new Promise<void>(resolve => {
      this.deferredTasks.push(resolve);
    });
  }

  /**
   * Releases a semaphore, allowing one more operation to proceed.
   *
   * @example
   * const sema = new Semaphore(1);
   *
   * async function task() {
   *   await sema.acquire();
   *   try {
   *     // This code can only be executed by two tasks at the same time
   *   } finally {
   *     sema.release(); // Allows another waiting task to proceed.
   *   }
   * }
   */
  release(): void {
    const deferredTask = this.deferredTasks.shift();

    if (deferredTask != null) {
      deferredTask();
      return;
    }

    if (this.available < this.capacity) {
      this.available++;
    }
  }
}

// denoCacheMetadata={"headers":{"date":"Thu, 26 Jun 2025 21:45:36 GMT","x-goog-generation":"1741509575249970","accept-ranges":"bytes","x-jsr-cache-status":"revalidated","content-type":"text/typescript","x-jsr-cache-id":"ATL","x-guploader-uploadid":"ABgVH8_SSwWeRmH6caK1Vpww6qsQszT3uodLqk4ir2MuIjPklHrgw8y5vQWRR7z9aAQjsflHFXv9uEA","alt-svc":"h3=\":443\"; ma=2592000,h3-29=\":443\"; ma=2592000","via":"1.1 google","expires":"Fri, 26 Jun 2026 21:45:36 GMT","content-length":"2666","cache-control":"public, max-age=31536000, immutable","x-goog-storage-class":"STANDARD","server":"UploadServer","access-control-allow-origin":"*","content-security-policy":"default-src 'none'; script-src 'none'; style-src 'none'; img-src 'none'; font-src 'none'; connect-src 'none'; frame-src 'none'; object-src 'none'; frame-ancestors 'none'; sandbox; form-action 'none';","x-content-type-options":"nosniff","age":"0","x-goog-stored-content-length":"2666","last-modified":"Sun, 09 Mar 2025 08:39:35 GMT","x-goog-metageneration":"1","etag":"\"755a68132bb0519256db126eb50becc7\"","x-goog-stored-content-encoding":"identity","x-robots-tag":"noindex","cross-origin-resource-policy":"cross-origin","x-goog-hash":"crc32c=pvINpA==,md5=dVpoEyuwUZJW2xJutQvsxw==","access-control-expose-headers":"*"},"url":"https://jsr.io/@es-toolkit/es-toolkit/1.33.0/src/promise/semaphore.ts","time":1750974334}