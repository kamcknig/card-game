import { debounce } from './debounce.ts';

interface ThrottleOptions {
  /**
   * An optional AbortSignal to cancel the debounced function.
   */
  signal?: AbortSignal;

  /**
   * An optional array specifying whether the function should be invoked on the leading edge, trailing edge, or both.
   * If `edges` includes "leading", the function will be invoked at the start of the delay period.
   * If `edges` includes "trailing", the function will be invoked at the end of the delay period.
   * If both "leading" and "trailing" are included, the function will be invoked at both the start and end of the delay period.
   * @default ["leading", "trailing"]
   */
  edges?: Array<'leading' | 'trailing'>;
}

export interface ThrottledFunction<F extends (...args: any[]) => void> {
  (...args: Parameters<F>): void;
  cancel: () => void;
  flush: () => void;
}

/**
 * Creates a throttled function that only invokes the provided function at most once
 * per every `throttleMs` milliseconds. Subsequent calls to the throttled function
 * within the wait time will not trigger the execution of the original function.
 *
 * @template F - The type of function.
 * @param {F} func - The function to throttle.
 * @param {number} throttleMs - The number of milliseconds to throttle executions to.
 * @returns {(...args: Parameters<F>) => void} A new throttled function that accepts the same parameters as the original function.
 *
 * @example
 * const throttledFunction = throttle(() => {
 *   console.log('Function executed');
 * }, 1000);
 *
 * // Will log 'Function executed' immediately
 * throttledFunction();
 *
 * // Will not log anything as it is within the throttle time
 * throttledFunction();
 *
 * // After 1 second
 * setTimeout(() => {
 *   throttledFunction(); // Will log 'Function executed'
 * }, 1000);
 */
export function throttle<F extends (...args: any[]) => void>(
  func: F,
  throttleMs: number,
  { signal, edges = ['leading', 'trailing'] }: ThrottleOptions = {}
): ThrottledFunction<F> {
  let pendingAt: number | null = null;

  const debounced = debounce(func, throttleMs, { signal, edges });

  const throttled = function (...args: Parameters<F>) {
    if (pendingAt == null) {
      pendingAt = Date.now();
    } else {
      if (Date.now() - pendingAt >= throttleMs) {
        pendingAt = Date.now();
        debounced.cancel();
        debounced(...args);
      }
    }

    debounced(...args);
  };

  throttled.cancel = debounced.cancel;
  throttled.flush = debounced.flush;

  return throttled;
}

// denoCacheMetadata={"headers":{"content-type":"text/typescript","last-modified":"Sun, 09 Mar 2025 08:39:35 GMT","content-security-policy":"default-src 'none'; script-src 'none'; style-src 'none'; img-src 'none'; font-src 'none'; connect-src 'none'; frame-src 'none'; object-src 'none'; frame-ancestors 'none'; sandbox; form-action 'none';","x-jsr-cache-status":"revalidated","cross-origin-resource-policy":"cross-origin","alt-svc":"h3=\":443\"; ma=2592000,h3-29=\":443\"; ma=2592000","x-jsr-cache-id":"ATL","access-control-expose-headers":"*","x-goog-metageneration":"1","x-guploader-uploadid":"ABgVH8_9-fT3OUUB_A9YBoLOZhEHVcIgGep39gkVh8NXf3YJAiwtLSJuO42oD6xmul99s-TvVpcAUec","x-goog-generation":"1741509575740574","content-length":"2524","date":"Thu, 26 Jun 2025 21:45:35 GMT","age":"0","access-control-allow-origin":"*","x-content-type-options":"nosniff","x-robots-tag":"noindex","etag":"\"ef631549c5a3e380b9db1cc58d6cb6c3\"","x-goog-stored-content-encoding":"identity","cache-control":"public, max-age=31536000, immutable","via":"1.1 google","accept-ranges":"bytes","server":"UploadServer","x-goog-stored-content-length":"2524","x-goog-storage-class":"STANDARD","expires":"Fri, 26 Jun 2026 21:45:35 GMT","x-goog-hash":"crc32c=X5XYRA==,md5=72MVScWj44C52xzFjWy2ww=="},"url":"https://jsr.io/@es-toolkit/es-toolkit/1.33.0/src/function/throttle.ts","time":1750974334}