import { isNull, isUndefined } from '../../predicate/index.ts';
import { isNaN } from '../predicate/isNaN.ts';
import { isNil } from '../predicate/isNil.ts';
import { isSymbol } from '../predicate/isSymbol.ts';

type Iteratee<T, R> = (value: T) => R;

const MAX_ARRAY_LENGTH = 4294967295;
const MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;
/**
 * This method is like `sortedIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @param {ArrayLike<T> | null | undefined} array The sorted array to inspect.
 * @param {T} value The value to evaluate.
 * @param {(value: T) => R} iteratee The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 * const objects = [{ 'n': 4 }, { 'n': 5 }]
 * sortedIndexBy(objects, { 'n': 4 }, ({ n }) => n)
 * // => 0
 */
export function sortedIndexBy<T, R>(
  array: ArrayLike<T> | null | undefined,
  value: T,
  iteratee?: Iteratee<T, R>,
  retHighest?: boolean
): number {
  let low = 0;
  let high = array == null ? 0 : array.length;
  if (high === 0 || isNil(array)) {
    return 0;
  }

  const transformedValue = iteratee?.(value);

  const valIsNaN = isNaN(transformedValue);
  const valIsNull = isNull(transformedValue);
  const valIsSymbol = isSymbol(transformedValue);
  const valIsUndefined = isUndefined(transformedValue);

  while (low < high) {
    let setLow: boolean;
    const mid = Math.floor((low + high) / 2);
    const computed = iteratee?.(array[mid]);

    const othIsDefined = !isUndefined(computed);
    const othIsNull = isNull(computed);
    const othIsReflexive = !isNaN(computed);
    const othIsSymbol = isSymbol(computed);

    if (valIsNaN) {
      setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed! <= transformedValue : computed! < transformedValue;
    }

    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return Math.min(high, MAX_ARRAY_INDEX);
}

// denoCacheMetadata={"headers":{"cache-control":"public, max-age=31536000, immutable","x-goog-generation":"1741509575454739","accept-ranges":"bytes","server":"UploadServer","x-jsr-cache-status":"revalidated","x-goog-stored-content-length":"2492","date":"Thu, 26 Jun 2025 21:45:35 GMT","access-control-allow-origin":"*","content-length":"2492","last-modified":"Sun, 09 Mar 2025 08:39:35 GMT","x-jsr-cache-id":"ATL","x-robots-tag":"noindex","x-content-type-options":"nosniff","alt-svc":"h3=\":443\"; ma=2592000,h3-29=\":443\"; ma=2592000","x-goog-stored-content-encoding":"identity","x-goog-storage-class":"STANDARD","access-control-expose-headers":"*","x-guploader-uploadid":"ABgVH8_Lz-v1sBVjZpp61ViBn9kp2wcgjdc5Zoam-vDA0xnh1O4bjO4uelu35KpWaV5yQ_p9sQdeV2c","x-goog-metageneration":"1","age":"0","via":"1.1 google","etag":"\"8b5ab05700a619f9def58bc254ac031e\"","content-type":"text/typescript","x-goog-hash":"crc32c=zLkFQw==,md5=i1qwVwCmGfne9YvCVKwDHg==","cross-origin-resource-policy":"cross-origin","expires":"Fri, 26 Jun 2026 21:45:35 GMT","content-security-policy":"default-src 'none'; script-src 'none'; style-src 'none'; img-src 'none'; font-src 'none'; connect-src 'none'; frame-src 'none'; object-src 'none'; frame-ancestors 'none'; sandbox; form-action 'none';"},"url":"https://jsr.io/@es-toolkit/es-toolkit/1.33.0/src/compat/array/sortedIndexBy.ts","time":1750974334}