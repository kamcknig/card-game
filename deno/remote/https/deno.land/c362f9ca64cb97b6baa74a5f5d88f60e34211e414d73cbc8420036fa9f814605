import {
  DefaultEventsMap,
  EventNames,
  EventParams,
  EventsMap,
} from "../../event-emitter/mod.ts";
import { Namespace } from "./namespace.ts";
import { Server } from "./server.ts";

export class ParentNamespace<
  ListenEvents extends EventsMap = DefaultEventsMap,
  EmitEvents extends EventsMap = DefaultEventsMap,
  ServerSideEvents extends EventsMap = DefaultEventsMap,
  SocketData = unknown,
> extends Namespace<ListenEvents, EmitEvents, ServerSideEvents, SocketData> {
  private static count = 0;

  private children: Set<
    Namespace<ListenEvents, EmitEvents, ServerSideEvents, SocketData>
  > = new Set();

  constructor(
    server: Server<ListenEvents, EmitEvents, ServerSideEvents, SocketData>,
  ) {
    super(server, "/_" + ParentNamespace.count++);
    // this.adapter = {
    //   broadcast(packet: Packet, opts: BroadcastOptions) {
    //     this.children.forEach((nsp: Namespace) => {
    //       nsp.adapter.broadcast(packet, opts);
    //     });
    //   }
    // };
  }

  override emit<Ev extends EventNames<EmitEvents>>(
    ev: Ev,
    ...args: EventParams<EmitEvents, Ev>
  ): boolean {
    this.children.forEach((nsp) => {
      nsp.emit(ev, ...args);
    });

    return true;
  }

  /* private */ _createChild(
    name: string,
  ): Namespace<ListenEvents, EmitEvents, ServerSideEvents, SocketData> {
    const namespace = new Namespace(this._server, name);
    namespace._fns = this._fns.slice(0);
    this.listeners("connect").forEach((listener) =>
      namespace.on("connect", listener)
    );
    this.listeners("connection").forEach((listener) =>
      namespace.on("connection", listener)
    );
    this.children.add(namespace);
    this._server._nsps.set(name, namespace);
    return namespace;
  }

  // fetchSockets(): Promise<RemoteSocket<EmitEvents, SocketData>[]> {
  //   // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the
  //   // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but
  //   // the behavior for namespaces created with a function is less clear
  //   // noteÂ²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace
  //   // may exist on one node but not exist on another (since it is created upon client connection)
  //   throw new Error("fetchSockets() is not supported on parent namespaces");
  // }
}

// denoCacheMetadata={"headers":{"cross-origin-opener-policy":"same-origin","last-modified":"Thu, 09 Jan 2025 07:38:36 GMT","access-control-allow-origin":"*","x-frame-options":"DENY","content-type":"application/typescript; charset=utf-8","cross-origin-resource-policy":"same-origin","accept-ranges":"bytes","content-length":"2451","age":"12809340","etag":"\"fe5088b89ec0b8e47fbed0bd02cc0f0f\"","referrer-policy":"strict-origin-when-cross-origin","date":"Wed, 29 Jan 2025 15:36:35 GMT","server":"deno/gcp-us-east4","server-timing":"fetchSource;dur=16","via":"http/2 edgeproxy-h","x-amz-cf-pop":"IAD61-P1","strict-transport-security":"max-age=63072000; includeSubDomains; preload","vary":"Accept-Encoding, Origin","x-amz-replication-status":"COMPLETED","cross-origin-embedder-policy":"same-origin","x-amz-server-side-encryption":"AES256","x-amz-version-id":"lCRA_lcEd28mV0kZCa77W_SmX3Q9HPKt","x-content-type-options":"nosniff","cache-control":"public, max-age=31536000, immutable","x-amz-cf-id":"OroxNHi4O5U8OAMGIqK5MjbAVtdeECpUJrFtW-B4rQeJBUEL5H91PA==","x-cache":"Hit from cloudfront","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox"},"url":"https://deno.land/x/socket_io@0.2.1/packages/socket.io/lib/parent-namespace.ts","time":1750974333}