import { debounce, type DebouncedFunction } from './debounce.ts';

interface ThrottleOptions {
  /**
   * An optional AbortSignal to cancel the function invocation on the trailing edge.
   */
  signal?: AbortSignal;

  /**
   * If `true`, the function will be invoked on the leading edge of the timeout.
   * @default true
   */
  leading?: boolean;

  /**
   * If `true`, the function will be invoked on the trailing edge of the timeout.
   * @default true
   */
  trailing?: boolean;
}

/**
 * Creates a throttled function that only invokes the provided function at most once
 * per every `throttleMs` milliseconds. Subsequent calls to the throttled function
 * within the wait time will not trigger the execution of the original function.
 *
 * @template F - The type of function.
 * @param {F} func - The function to throttle.
 * @param {number} throttleMs - The number of milliseconds to throttle executions to.
 * @param {ThrottleOptions} options - The options object
 * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the throttled function.
 * @param {boolean} options.leading - If `true`, the function will be invoked on the leading edge of the timeout.
 * @param {boolean} options.trailing - If `true`, the function will be invoked on the trailing edge of the timeout.
 * @returns {(...args: Parameters<F>) => void} A new throttled function that accepts the same parameters as the original function.
 *
 * @example
 * const throttledFunction = throttle(() => {
 *   console.log('Function executed');
 * }, 1000);
 *
 * // Will log 'Function executed' immediately
 * throttledFunction();
 *
 * // Will not log anything as it is within the throttle time
 * throttledFunction();
 *
 * // After 1 second
 * setTimeout(() => {
 *   throttledFunction(); // Will log 'Function executed'
 * }, 1000);
 */
export function throttle<F extends (...args: any[]) => any>(
  func: F,
  throttleMs = 0,
  options: ThrottleOptions = {}
): DebouncedFunction<F> {
  if (typeof options !== 'object') {
    options = {};
  }

  const { leading = true, trailing = true, signal } = options;

  return debounce(func, throttleMs, {
    leading,
    trailing,
    signal,
    maxWait: throttleMs,
  });
}

// denoCacheMetadata={"headers":{"last-modified":"Sun, 09 Mar 2025 08:39:34 GMT","date":"Thu, 26 Jun 2025 21:45:35 GMT","x-goog-hash":"crc32c=5Wccug==,md5=tAKgDDVwXMFiIzOdNxw4Xg==","x-content-type-options":"nosniff","alt-svc":"h3=\":443\"; ma=2592000,h3-29=\":443\"; ma=2592000","age":"0","content-type":"text/typescript","x-goog-stored-content-encoding":"identity","expires":"Fri, 26 Jun 2026 21:45:35 GMT","cache-control":"public, max-age=31536000, immutable","x-jsr-cache-status":"revalidated","content-length":"2213","x-robots-tag":"noindex","x-jsr-cache-id":"ATL","accept-ranges":"bytes","x-goog-metageneration":"1","via":"1.1 google","access-control-allow-origin":"*","x-goog-generation":"1741509574751268","x-goog-storage-class":"STANDARD","access-control-expose-headers":"*","cross-origin-resource-policy":"cross-origin","x-goog-stored-content-length":"2213","etag":"\"b402a00c35705cc16223339d371c385e\"","content-security-policy":"default-src 'none'; script-src 'none'; style-src 'none'; img-src 'none'; font-src 'none'; connect-src 'none'; frame-src 'none'; object-src 'none'; frame-ancestors 'none'; sandbox; form-action 'none';","x-guploader-uploadid":"ABgVH8_H_dG3aAhuVejQW4WrDGQEm_qXCJseNDFOjrYcetrpe9S9m_ZJdLf2mtKX-OJwggF_XcA35Hw","server":"UploadServer"},"url":"https://jsr.io/@es-toolkit/es-toolkit/1.33.0/src/compat/function/throttle.ts","time":1750974334}