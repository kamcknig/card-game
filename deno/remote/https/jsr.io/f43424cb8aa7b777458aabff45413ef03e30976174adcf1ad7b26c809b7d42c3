import { isPlainObject } from '../predicate/isPlainObject.ts';

/**
 * Merges the properties of the source object into the target object.
 *
 * This function performs a deep merge, meaning nested objects and arrays are merged recursively.
 * If a property in the source object is an array or an object and the corresponding property in the target object is also an array or object, they will be merged.
 * If a property in the source object is undefined, it will not overwrite a defined property in the target object.
 *
 * Note that this function mutates the target object.
 *
 * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.
 * @param {S} source - The source object whose properties will be merged into the target object.
 * @returns {T & S} The updated target object with properties from the source object merged in.
 *
 * @template T - Type of the target object.
 * @template S - Type of the source object.
 *
 * @example
 * const target = { a: 1, b: { x: 1, y: 2 } };
 * const source = { b: { y: 3, z: 4 }, c: 5 };
 *
 * const result = merge(target, source);
 * console.log(result);
 * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }
 *
 * @example
 * const target = { a: [1, 2], b: { x: 1 } };
 * const source = { a: [3], b: { y: 2 } };
 *
 * const result = merge(target, source);
 * console.log(result);
 * // Output: { a: [3, 2], b: { x: 1, y: 2 } }
 *
 * @example
 * const target = { a: null };
 * const source = { a: [1, 2, 3] };
 *
 * const result = merge(target, source);
 * console.log(result);
 * // Output: { a: [1, 2, 3] }
 */
export function merge<T extends Record<PropertyKey, any>, S extends Record<PropertyKey, any>>(
  target: T,
  source: S
): T & S {
  const sourceKeys = Object.keys(source) as Array<keyof S>;

  for (let i = 0; i < sourceKeys.length; i++) {
    const key = sourceKeys[i];

    const sourceValue = source[key];
    const targetValue = target[key];

    if (Array.isArray(sourceValue)) {
      if (Array.isArray(targetValue)) {
        target[key] = merge(targetValue, sourceValue);
      } else {
        target[key] = merge([], sourceValue);
      }
    } else if (isPlainObject(sourceValue)) {
      if (isPlainObject(targetValue)) {
        target[key] = merge(targetValue, sourceValue);
      } else {
        target[key] = merge({}, sourceValue);
      }
    } else if (targetValue === undefined || sourceValue !== undefined) {
      target[key] = sourceValue;
    }
  }

  return target;
}

// denoCacheMetadata={"headers":{"cross-origin-resource-policy":"cross-origin","x-content-type-options":"nosniff","x-guploader-uploadid":"ABgVH8-5ZX1U_ATkeaseMCfg1tFUeMIgxQ7w5Ct-xSmin8Z_rDVCn8mFhFfxKHt3xLB8IBuV","x-jsr-cache-id":"ATL","alt-svc":"h3=\":443\"; ma=2592000,h3-29=\":443\"; ma=2592000","content-length":"2522","x-goog-generation":"1741509574891507","x-goog-stored-content-encoding":"identity","x-goog-stored-content-length":"2522","accept-ranges":"bytes","cache-control":"public, max-age=31536000, immutable","etag":"\"59721b790ec953a78f9d48150eb620ac\"","via":"1.1 google","access-control-allow-origin":"*","access-control-expose-headers":"*","content-security-policy":"default-src 'none'; script-src 'none'; style-src 'none'; img-src 'none'; font-src 'none'; connect-src 'none'; frame-src 'none'; object-src 'none'; frame-ancestors 'none'; sandbox; form-action 'none';","x-goog-hash":"crc32c=7OMlXw==,md5=WXIbeQ7JU6ePnUgVDrYgrA==","x-goog-metageneration":"1","last-modified":"Sun, 09 Mar 2025 08:39:34 GMT","x-goog-storage-class":"STANDARD","date":"Thu, 26 Jun 2025 21:45:36 GMT","x-robots-tag":"noindex","x-jsr-cache-status":"revalidated","age":"0","server":"UploadServer","content-type":"text/typescript","expires":"Fri, 26 Jun 2026 21:45:36 GMT"},"url":"https://jsr.io/@es-toolkit/es-toolkit/1.33.0/src/object/merge.ts","time":1750974334}